--- movieplayer.cpp.orig	2004-10-06 09:13:53.000000000 +0200
+++ movieplayer.cpp	2004-10-06 09:25:40.000000000 +0200
@@ -23,6 +23,8 @@
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+   optimized by - gmo18t
+   $Id: movieplayer.cpp.diff,v 1.1 2004/10/07 12:11:27 essu Exp $
 */
 
 #ifdef HAVE_CONFIG_H
@@ -110,10 +112,10 @@
 #define MINUTEOFFSET 30898176
 	
 
-static CMoviePlayerGui::state playstate;
+static CMoviePlayerGui::state g_playstate;
 static bool isTS, isPES, isBookmark;
-int speed = 1;
-static long long fileposition;
+int g_speed = 1;
+static off_t g_fileposition;
 ringbuffer_t *ringbuf;
 bool bufferfilled;
 int streamingrunning;
@@ -125,9 +127,9 @@
 std::string startfilename;
 std::string skipvalue;
 
-long long startposition;
-int jumpminutes = 1;
-int buffer_time = 0;
+off_t g_startposition = 0L;
+int   g_jumpminutes   = 0;
+int   buffer_time     = 0;
 
 unsigned short apids[10];
 unsigned short ac3flags[10];
@@ -169,29 +171,29 @@
 {
 	frameBuffer = CFrameBuffer::getInstance();
 
-	if (strlen (g_settings.network_nfs_moviedir) != 0)
-		Path_local = g_settings.network_nfs_moviedir;
+        if (strlen (g_settings.network_nfs_moviedir) != 0)
+	  Path_local = g_settings.network_nfs_moviedir;
 	else
-		Path_local = "/";
+	  Path_local = "/";
 	Path_vlc  = "vlc://";
 	Path_vlc += g_settings.streaming_server_startdir;
 	Path_vlc_settings = g_settings.streaming_server_startdir;
-
-	if (g_settings.filebrowser_denydirectoryleave)
-		filebrowser = new CFileBrowser(Path_local.c_str());
+	
+        if (g_settings.filebrowser_denydirectoryleave) 
+          filebrowser = new CFileBrowser (Path_local.c_str());  // with filebrowser patch 
 	else
-		filebrowser = new CFileBrowser();
-
-	filebrowser->Multi_Select = false;
+	  filebrowser = new CFileBrowser();
+        filebrowser->Multi_Select = false;
 	filebrowser->Dirs_Selectable = false;
-	tsfilefilter.addFilter ("ts");
+	
+        tsfilefilter.addFilter ("ts");
 	vlcfilefilter.addFilter ("mpg");
 	vlcfilefilter.addFilter ("mpeg");
 	vlcfilefilter.addFilter ("m2p");
 	vlcfilefilter.addFilter ("avi");
 	vlcfilefilter.addFilter ("vob");
-	pesfilefilter.addFilter ("mpv");
-	filebrowser->Filter = &tsfilefilter;
+	
+        filebrowser->Filter = &tsfilefilter;
 }
 
 //------------------------------------------------------------------------
@@ -257,7 +259,7 @@
 
     isBookmark=false;
     startfilename = "";
-    startposition = 0;
+    g_startposition = 0;
     isTS=false;
     isPES=false;
     
@@ -275,14 +277,14 @@
         PlayFile();
 	}
 	else if (actionKey=="pesplayback") {
-        isPES=true;
-        PlayFile();
+        //isPES=true;
+        ParentalEntrance();
 	}
 	else if (actionKey=="bookmarkplayback") {
         isBookmark = true;
         if (theBookmark != NULL) {
             startfilename = theBookmark->getUrl();
-            sscanf (theBookmark->getTime(), "%lld", &startposition);
+            sscanf (theBookmark->getTime(), "%lld", &g_startposition);
             int vlcpos = startfilename.rfind("vlc://");
             if (vlcpos==0)
             {
@@ -361,7 +363,7 @@
 	if (httpres != 0)
 	{
 		DisplayErrorMessage(g_Locale->getText(LOCALE_MOVIEPLAYER_NOSTREAMINGSERVER)); // UTF-8
-		playstate = CMoviePlayerGui::STOPPED;
+		g_playstate = CMoviePlayerGui::STOPPED;
 		pthread_exit (NULL);
 		// Assume safely that all succeeding HTTP requests are successful
 	}
@@ -522,7 +524,7 @@
 	if (!VlcSendPlaylist((char*)mrl))
 	{
 		DisplayErrorMessage(g_Locale->getText(LOCALE_MOVIEPLAYER_NOSTREAMINGSERVER)); // UTF-8
-		playstate = CMoviePlayerGui::STOPPED;
+		g_playstate = CMoviePlayerGui::STOPPED;
 		pthread_exit (NULL);
 		// Assume safely that all succeeding HTTP requests are successful
 	}
@@ -583,7 +585,7 @@
 		if (connect(skt, (struct sockaddr *) &servAddr, sizeof (servAddr)) < 0)
 		{
 			perror ("SOCKET");
-			playstate = CMoviePlayerGui::STOPPED;
+			g_playstate = CMoviePlayerGui::STOPPED;
 			pthread_exit (NULL);
 		}
 		fcntl (skt, O_NONBLOCK);
@@ -595,7 +597,7 @@
 		if (send (skt, msg, msglen, 0) == -1)
 		{
 			perror ("send()");
-			playstate = CMoviePlayerGui::STOPPED;
+			g_playstate = CMoviePlayerGui::STOPPED;
 			pthread_exit (NULL);
 		}
 
@@ -649,7 +651,7 @@
 
 	while (streamingrunning == 1)
 	{
-		if (playstate == CMoviePlayerGui::STOPPED)
+		if (g_playstate == CMoviePlayerGui::STOPPED)
 		{
 			close(skt);
 			pthread_exit (NULL);
@@ -703,7 +705,7 @@
 			    ((poller[0].revents & (POLLHUP | POLLERR | POLLNVAL)) != 0))
 			{
 				perror ("Error while polling()");
-				playstate = CMoviePlayerGui::STOPPED;
+				g_playstate = CMoviePlayerGui::STOPPED;
 				close(skt);
 				pthread_exit (NULL);
 			}
@@ -729,12 +731,12 @@
 			}
 			else
 			{
-				if (playstate == CMoviePlayerGui::PLAY) {
+				if (g_playstate == CMoviePlayerGui::PLAY) {
 					nothingreceived++;
 					if (nothingreceived > (buffer_time + 3)*100) // wait at least buffer time secs +3 to play buffer when stream ends
 					{
 						printf ("[movieplayer.cpp] ReceiveStreamthread: Didn't receive for a while. Stopping.\n");
-						playstate = CMoviePlayerGui::STOPPED;	
+						g_playstate = CMoviePlayerGui::STOPPED;	
 					}
 					usleep(10000); //sleep 10 ms
 				}
@@ -790,7 +792,7 @@
 		failed = true;
 	}
 
-	playstate = CMoviePlayerGui::SOFTRESET;
+	g_playstate = CMoviePlayerGui::SOFTRESET;
 	printf ("[movieplayer.cpp] read starting\n");
 	size_t readsize, len;
 	len = 0;
@@ -803,7 +805,7 @@
 	
 	checkAspectRatio(vdec, true);
 	
-	while (playstate > CMoviePlayerGui::STOPPED)
+	while (g_playstate > CMoviePlayerGui::STOPPED)
 	{
 		readsize = ringbuffer_read_space (ringbuf);
 		if (readsize > MAXREADSIZE)
@@ -867,16 +869,16 @@
 
 			len = ringbuffer_read (ringbuf, buf, (readsize / 188) * 188);
 
-			if (startposition > 0) {
+			if (g_startposition > 0) {
 			    printf ("[movieplayer.cpp] Was Bookmark. Skipping to startposition\n");
 			    char tmpbuf[30];
-			    sprintf(tmpbuf,"%lld",startposition);
+			    sprintf(tmpbuf,"%lld",g_startposition);
 			    skipvalue = tmpbuf;
-			    startposition = 0;
-			    playstate = CMoviePlayerGui::SKIP;
+			    g_startposition = 0;
+			    g_playstate = CMoviePlayerGui::SKIP;
 			}
 
-			switch (playstate)
+			switch (g_playstate)
 			{
 			case CMoviePlayerGui::PAUSE:
 				//ioctl (dmxv, DMX_STOP);
@@ -885,7 +887,7 @@
 				// pause VLC
 	            httpres = sendGetRequest(pauseurl, response, false);
 
-				while (playstate == CMoviePlayerGui::PAUSE)
+				while (g_playstate == CMoviePlayerGui::PAUSE)
 				{
 					//ioctl (dmxv, DMX_STOP);	
 					//ioctl (dmxa, DMX_STOP);
@@ -893,7 +895,7 @@
 				}
 				// unpause VLC
 				httpres = sendGetRequest(unpauseurl, response, false);
-				speed = 1;
+				g_speed = 1;
 				break;
 			case CMoviePlayerGui::SKIP:
 			{
@@ -906,8 +908,8 @@
 				int bytes = (ringbuffer_read_space(ringbuf) / 188) * 188;
 				ringbuffer_read_advance(ringbuf, bytes);
 				httpres = sendGetRequest(skipurl, response, false);
-//				playstate = CMoviePlayerGui::RESYNC;
-				playstate = CMoviePlayerGui::PLAY;
+//				g_playstate = CMoviePlayerGui::RESYNC;
+				g_playstate = CMoviePlayerGui::PLAY;
 			}
 			break;
 			case CMoviePlayerGui::RESYNC:
@@ -923,7 +925,7 @@
 				bufferingBox->paint();
 				bufferfilled = false;
 				ioctl (dmxa, DMX_START);
-				playstate = CMoviePlayerGui::PLAY;
+				g_playstate = CMoviePlayerGui::PLAY;
 				break;
 			case CMoviePlayerGui::PLAY:
 				if (len < MINREADSIZE)
@@ -951,7 +953,7 @@
 						{
 							perror("[movieplayer.cpp] PlayStreamThread: write failed");
 #warning I have no clue except what to do if writing fails so I just set playstate to CMoviePlayerGui::STOPPED
-							playstate = CMoviePlayerGui::STOPPED;
+							g_playstate = CMoviePlayerGui::STOPPED;
 							break;
 						}
 						else
@@ -987,8 +989,8 @@
 				ioctl (dmxv, DMX_SET_PES_FILTER, &p);
 				ioctl (dmxv, DMX_START);
 				ioctl (dmxa, DMX_START);
-				speed = 1;
-				playstate = CMoviePlayerGui::PLAY;
+				g_speed = 1;
+				g_playstate = CMoviePlayerGui::PLAY;
 				break;
 			case CMoviePlayerGui::STOPPED:
 			case CMoviePlayerGui::PREPARING:
@@ -1034,508 +1036,1503 @@
 	pthread_exit (NULL);
 }
 
-//------------------------------------------------------------------------
-void *
-PlayPESFileThread (void *filename)
+//== updateLcd ==
+//===============
+void updateLcd(const std::string & sel_filename)
 {
-	struct pollfd pfd[2];
-	unsigned char abuf[188 * 188], vbuf[188 * 188];
-	const char *afilename, *vfilename;
-	int adec, vdec, afile, vfile;
-	ssize_t awr, vwr;
-	size_t ar = 0, vr = 0;
-	int adone = 0, vdone = 0;
-	unsigned int acaps, vcaps;
-
-	vfilename = (const char*) filename;
+  static int   l_playstate = -1;
+  char         tmp[20];
+  std::string  lcd;
+	
+  if (l_playstate == g_playstate) return;
+
+  switch(g_playstate)
+  {
+    case CMoviePlayerGui::PAUSE:
+	lcd = "|| (";
+	lcd += sel_filename;
+	lcd += ')';
+	break;
+
+    case CMoviePlayerGui::REW:
+	sprintf(tmp, "%dx<< ", g_speed);
+	lcd = tmp;
+	lcd += sel_filename;
+	break;
+
+    case CMoviePlayerGui::FF:
+	sprintf(tmp, "%dx>> ", g_speed);
+	lcd = tmp;
+	lcd += sel_filename;
+	break;
+
+    default:
+	lcd = "> ";
+	lcd += sel_filename;
+	break;
+  }
 	
-    std::string afilenametmp = vfilename;
-    afilenametmp = afilenametmp.substr(0,afilenametmp.length()-3);
-    afilenametmp += "mp2";
-    afilename = afilenametmp.c_str();
-	//afilename = "/mnt/movies/testfilm.mp2";
-	
-	printf("[movieplayer.cpp] Starting PES Playback\n");
-	printf("[movieplayer.cpp] vfile=%s\n",vfilename);
-	printf("[movieplayer.cpp] afile=%s\n",afilename);
-	
-	if ((adec = open(ADEC, O_WRONLY | O_NONBLOCK)) < 0) {
-		perror(ADEC);
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+  CLCD::getInstance()->showServicename(lcd);
+}
 
-	if ((vdec = open(VDEC, O_WRONLY)) < 0) {
-		perror(VDEC);
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+// GMO snip start ...
 
-	if ((afile = open(afilename, O_RDONLY)) < 0) {
-		perror(afilename);
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+#define MP_WITH_PCR 1  // use video stream as pcr source
 
-	if ((vfile = open(vfilename, O_RDONLY)) < 0) {
-		perror(vfilename);
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+//===========================	
+//== PlayFile Thread Stuff ==
+//===========================
+#define PF_BUF_SIZE   (800*188)	
+#define PF_DMX_SIZE   (PF_BUF_SIZE + PF_BUF_SIZE/2)
+#define PF_RD_TIMEOUT 3000
+#define PF_EMPTY      0
+#define PF_READY      1
+#define PF_LST_ITEMS  30
+#define PF_SKPOS_OFFS MINUTEOFFSET
+#define PF_JMP_DIV    4  
+#define PF_JMP_START  0
+#define PF_JMP_MID    5555
+#define PF_JMP_END    9999
+
+//-- live stream item --
+//----------------------
+typedef struct 
+{
+  std::string        pname;
+  std::string        ip;
+  int                port;
+  int                vpid;
+  int                apid;
+  long long          zapid;
+
+} MP_LST_ITEM;
+
+//-- main player context --
+//-------------------------
+typedef struct
+{
+  struct dmx_pes_filter_params p;
+  short                        ac3;
+  unsigned short               pida;
+  unsigned short               pidv;
+
+  struct pollfd *pH;
+
+  int   inFd;
+  int   dvr;
+  int   dmxv;
+  int   dmxa;
+  int   dmxp;
+  int   vdec;
+  int   adec;
+  
+  off_t pos;
+  off_t fileSize;
 
-	if (ioctl(adec, AUDIO_GET_CAPABILITIES, &acaps) < 0) {
-		perror("AUDIO_GET_CAPABILITIES");
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+  int   readSize;  
+  char  dvrBuf[PF_BUF_SIZE];
+  bool  refillBuffer;
+  bool  startDMX;
 
-	if (ioctl(vdec, VIDEO_GET_CAPABILITIES, &vcaps) < 0) {
-		perror("VIDEO_GET_CAPABILITIES");
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+  bool  isStream;
+  bool  canPause;
+  
+  bool        itChanged;
+  int         it;
+  int         lst_cnt;
+  MP_LST_ITEM lst[PF_LST_ITEMS];
+
+} MP_CTX;
+
+//-- some bullshit global values --
+#ifndef _MP_SIMULATOR
+static int g_itno = 0;
+#endif
 
-	if (!(acaps & AUDIO_CAP_MP2)) {
-		fprintf(stderr, "audio decoder does not support mpeg2 pes\n");
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+static bool mp_openDVBDevices(MP_CTX *ctx);
+static void mp_closeDVBDevices(MP_CTX *ctx);
+static void mp_softReset(MP_CTX *ctx);
+static void mp_freezeAV(MP_CTX *ctx);
+static void mp_unfreezeAV(MP_CTX *ctx);
+static void mp_startDMX(MP_CTX *ctx);
+static void mp_checkEvent(MP_CTX *ctx);
+static bool mp_probe(const char *fname, MP_CTX *ctx);
+static void mp_analyze(MP_CTX *ctx);
+
+//== seek to pos with sync to next proper TS packet ==
+//== returns offset to start of TS packet or actual ==
+//== pos on failure.                                ==
+//==================================================== 
+#define SIZE_TS_PKT 188
+#define SIZE_PROBE  (100*SIZE_TS_PKT)
 
-	if (!(vcaps & VIDEO_CAP_MPEG2)) {
-		fprintf(stderr, "video decoder does not support mpeg2 pes\n");
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+static off_t mp_seekSync(int fd, off_t pos)
+{
+  off_t   npos = pos;
+  uint8_t pkt[SIZE_TS_PKT];
+ 
+  lseek(fd, npos, SEEK_SET); 
+  while ( read(fd, pkt, 1) > 0 )
+  {
+    //-- check every byte until sync word reached --
+    npos++;
+    if (*pkt == 0x47) 
+    {
+      //-- if found double check for next sync word --
+      if ( read(fd, pkt, SIZE_TS_PKT) == SIZE_TS_PKT )
+      {
+        if (pkt[SIZE_TS_PKT-1] == 0x47) 
+          return lseek(fd, npos-1, SEEK_SET); // assume sync ok
+        else
+          lseek(fd, npos, SEEK_SET);  // ups, next pkt doesn't start with sync 
+      }
+    }
+    
+    //-- check probe limits --
+    if (npos > (pos+SIZE_PROBE)) break; 
+  }
+  
+  //-- on error stay on actual position -- 
+  return lseek(fd, 0, SEEK_CUR);
+}
 
-	if (ioctl(adec, AUDIO_SELECT_SOURCE, AUDIO_SOURCE_MEMORY) < 0) {
-		perror("AUDIO_SELECT_SOURCE");
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+//== open/close DVB devices ==
+//============================
+static bool mp_openDVBDevices(MP_CTX *ctx)
+{
+  //-- may prevent black screen after restart ... --
+  //------------------------------------------------
+  usleep(150000);
+  
+  ctx->dmxa = -1;
+  ctx->dmxv = -1;
+  ctx->dmxp = -1;
+  ctx->dvr  = -1;
+  ctx->adec = -1;
+  ctx->vdec = -1;
+
+  if ((ctx->dmxa = open(DMX, O_RDWR)) < 0
+       || (ctx->dmxv = open(DMX, O_RDWR)) < 0
+#ifdef MP_WITH_PCR
+       || (ctx->dmxp = open(DMX, O_RDWR)) < 0
+#endif
+       || (ctx->dvr = open(DVR, O_WRONLY)) < 0
+       || (ctx->adec = open(ADEC, O_RDWR)) < 0 || (ctx->vdec = open(VDEC, O_RDWR)) < 0)
+  {  
+    return false;
+  }
+  return true;
+}
 
-	if (ioctl(vdec, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_MEMORY) < 0) {
-		perror("VIDEO_SELECT_SOURCE");
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+static void mp_closeDVBDevices(MP_CTX *ctx)
+{
+  //-- may prevent black screen after restart ... --
+  //------------------------------------------------
+  usleep(150000);
+
+  if (ctx->vdec != -1) 
+  {
+    ioctl (ctx->vdec, VIDEO_STOP);
+    close (ctx->vdec);
+  }
+  if (ctx->adec != -1) 
+  {
+    ioctl (ctx->adec, AUDIO_STOP);
+    close (ctx->adec);
+  }
+
+#ifdef MP_WITH_PCR
+  if (ctx->dmxp != -1) 
+  {
+    ioctl (ctx->dmxp, DMX_STOP);
+    close(ctx->dmxp);
+  }  
+#endif
 
-	if (ioctl(adec, AUDIO_SET_STREAMTYPE, AUDIO_CAP_MP2) < 0) {
-		perror("AUDIO_SET_STREAMTYPE");
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+  if (ctx->dmxa != -1) 
+  {
+    ioctl (ctx->dmxa, DMX_STOP);
+    close(ctx->dmxa);
+  }
+  if (ctx->dmxv != -1) 
+  {
+    ioctl (ctx->dmxv, DMX_STOP);
+    close(ctx->dmxv);
+  }
+  if (ctx->dvr!= -1) close(ctx->dvr);
+ 
+  ctx->dmxp = -1;
+  ctx->dmxa = -1;
+  ctx->dmxv = -1;
+  ctx->dvr  = -1;
+  ctx->adec = -1;
+  ctx->vdec = -1;
+}
 
-	if (ioctl(vdec, VIDEO_SET_STREAMTYPE, VIDEO_CAP_MPEG2) < 0) {
-		perror("VIDEO_SET_STREAMTYPE");
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+//== mp_softReset ==
+//==================
+static void mp_softReset(MP_CTX *ctx)
+{
+  //-- stop DMX devices --
+#ifdef MP_WITH_PCR
+  ioctl(ctx->dmxp, DMX_STOP);
+#endif
+  ioctl(ctx->dmxv, DMX_STOP);
+  ioctl(ctx->dmxa, DMX_STOP);
 
-	if (ioctl(adec, AUDIO_PLAY) < 0) {
-		perror("AUDIO_PLAY");
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+  //-- stop AV devices --
+  ioctl(ctx->vdec, VIDEO_STOP);
+  ioctl(ctx->adec, AUDIO_STOP);
+
+  //-- setup DMX devices (again) --
+  ctx->p.input    = DMX_IN_DVR;
+  ctx->p.output   = DMX_OUT_DECODER;
+  ctx->p.flags    = 0; 
+
+  ctx->p.pid      = ctx->pida;
+  ctx->p.pes_type = DMX_PES_AUDIO;
+
+  ioctl (ctx->dmxa, DMX_SET_BUFFER_SIZE, PF_DMX_SIZE/4);
+  ioctl (ctx->dmxa, DMX_SET_PES_FILTER, &(ctx->p));
+
+  ctx->p.pid      = ctx->pidv;
+  ctx->p.pes_type = DMX_PES_VIDEO;
+  ioctl (ctx->dmxv, DMX_SET_BUFFER_SIZE, PF_DMX_SIZE);
+  ioctl (ctx->dmxv, DMX_SET_PES_FILTER, &(ctx->p));
+
+#ifdef MP_WITH_PCR
+  //-- NEW: use vpid stream as pcr stream too !!! --
+  ctx->p.pid      = ctx->pidv;
+  ctx->p.pes_type = DMX_PES_PCR;
+  ioctl (ctx->dmxp, DMX_SET_PES_FILTER, &(ctx->p));
+#endif
 
-	if (ioctl(vdec, VIDEO_PLAY) < 0) {
-		perror("VIDEO_PLAY");
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
-		
-	printf("[movieplayer.cpp] Starting PES Playback. All preparations done.\n");
-	
-	pfd[0].fd = afile;
-	pfd[0].events = POLLOUT;
-	pfd[1].fd = vfile;
-	pfd[1].events = POLLOUT;
+  //-- switch audio decoder bypass depending on audio type --  
+  if (ctx->ac3 == 1) 
+    ioctl(ctx->adec, AUDIO_SET_BYPASS_MODE,0UL); // bypass on
+  else
+    ioctl(ctx->adec, AUDIO_SET_BYPASS_MODE,1UL); // bypass off
+
+  //-- start AV devices again --
+  ioctl(ctx->adec, AUDIO_PLAY);             // audio
+  ioctl(ctx->vdec, VIDEO_PLAY);             // video
+  ioctl(ctx->adec, AUDIO_SET_AV_SYNC, 1UL); // needs sync !
+  
+  //-- but never start demuxers here, because this will --
+  //-- be done outside (e.g. short before writing.)     --
+  ctx->refillBuffer = true;
+  ctx->startDMX     = true;
+}
 
-	checkAspectRatio(vdec, true);
+//== mp_freezeAV ==
+//=================
+static void mp_freezeAV(MP_CTX *ctx)
+{
+  //-- freeze (pause) AV playback immediate --
+  ioctl(ctx->vdec, VIDEO_FREEZE);
+  ioctl(ctx->adec, AUDIO_PAUSE);
+
+  //-- workaround: switch off decoder bypass for AC3 audio -- 
+  if (ctx->ac3 == 1) 
+    ioctl(ctx->adec, AUDIO_SET_BYPASS_MODE, 1UL);
+}
 
-	while (playstate >= CMoviePlayerGui::PLAY) {
-    		switch (playstate)
-			{
-			case CMoviePlayerGui::PAUSE:
-				while (playstate == CMoviePlayerGui::PAUSE)
-				{
-					usleep(100000); // no busy wait
-				}
-				break;
-			// ignore playstates.
-			// TODO: implement them
-			case CMoviePlayerGui::PREPARING:
-			case CMoviePlayerGui::STREAMERROR:
-			case CMoviePlayerGui::RESYNC:
-		    case CMoviePlayerGui::FF:
-			case CMoviePlayerGui::REW:
-			case CMoviePlayerGui::JF:
-			case CMoviePlayerGui::JB:
-			case CMoviePlayerGui::SOFTRESET:
-                playstate = CMoviePlayerGui::PLAY;
-				break;
-			case CMoviePlayerGui::PLAY:
-			case CMoviePlayerGui::STOPPED:
-			case CMoviePlayerGui::SKIP:
-			case CMoviePlayerGui::AUDIOSELECT:
-			    break;
-			}
+//== mp_unfreezeAV ==
+//===================
+static void mp_unfreezeAV(MP_CTX *ctx)
+{
+  //-- continue AV playback immediate --
+  ioctl(ctx->vdec, VIDEO_CONTINUE);
+  ioctl(ctx->adec, AUDIO_CONTINUE);
+
+  //-- workaround: switch on decoder bypass for AC3 audio -- 
+  if (ctx->ac3 == 1) 
+    ioctl(ctx->adec, AUDIO_SET_BYPASS_MODE, 0UL);
+}
 
-    	
-		if (ar <= 0) {
-			if ((ar = read(afile, abuf, sizeof(abuf))) < 0) {
-				perror("audio read");
-				playstate = CMoviePlayerGui::STOPPED;
-				break;
-			}
-			adone = 0;
-			printf("[movieplayer.cpp] adone=0\n");
-		}
-		if (vr <= 0) {
-			if ((vr = read(vfile, vbuf, sizeof(vbuf))) < 0) {
-				perror("video read");
-				playstate = CMoviePlayerGui::STOPPED;
-				break;
-			}
-			vdone = 0;
-			printf("[movieplayer.cpp] vdone=0\n");
-		}
+//== mp_startDMX ==
+//=================
+static void mp_startDMX(MP_CTX *ctx)
+{
+  if (ctx->startDMX)
+  {
+    ioctl (ctx->dmxa, DMX_START); // audio first !
+    ioctl (ctx->dmxv, DMX_START);
+#ifdef MP_WITH_MCR
+    ioctl (ctx->dmxp, DMX_START);
+#endif    
+    ctx->startDMX = false;
+  }
+}
+
+//== mp_checkEvent ==
+//===================
+static void mp_checkEvent(MP_CTX *ctx)
+{
+  switch (g_playstate)
+  {
+    //-- Pause --
+    //-----------
+    case CMoviePlayerGui::PAUSE:
+      //-- live stream won't pause --
+      if (!ctx->canPause)
+      {
+        g_playstate = CMoviePlayerGui::PLAY;
+        break;
+      }
+
+      //-- Freeze AV --
+      mp_freezeAV(ctx);
+
+      fprintf(stderr, "[mp] pause\n");
+      while (g_playstate == CMoviePlayerGui::PAUSE) usleep(10000);
+      fprintf(stderr, "[mp] continue\n");
+      
+      //-- after unpause, a call to "SoftReset" --
+      //-- will initialize all devices again,   --
+      //-- but demuxer will be started later.   --
+      mp_softReset(ctx);
+      break;
+
+    //-- next item of program/play-list   --
+    //-------------------------------------- 
+    case CMoviePlayerGui::ITEMSELECT:
+      g_playstate = CMoviePlayerGui::PLAY;
+
+      //-- TODO: may be sometimes will it work for (live) streams --
+      if (ctx->isStream) break; // finish
+      
+      if (ctx->lst_cnt)
+      {
+        ctx->itChanged = true;
+        switch (g_itno)
+        {
+          //-- previous item --
+          case -2:
+            ctx->it -= 1;
+            if (ctx->it < 0) ctx->it = ctx->lst_cnt-1;
+            fprintf(stderr,"[mp] previous item [%d]\n", ctx->it);
+            break;
 
-		if ((ar == 0) && (vr == 0)) {
-            playstate = CMoviePlayerGui::STOPPED;
+          //-- next item --
+          case -1:
+            ctx->it += 1;
+            if (ctx->it >= ctx->lst_cnt) ctx->it = 0;
+            fprintf(stderr, "[mp] next item [%d]\n", ctx->it);
+            break;
+
+          //-- directly selected number --
+          default:
+            if (ctx->it != g_itno)
+            {
+              if (g_itno >= ctx->lst_cnt)
+                ctx->it = ctx->lst_cnt-1;
+              else
+                ctx->it = g_itno;
+              fprintf(stderr, "[mp] selecting item [%d]\n", ctx->it);
+            }
+            else
+              ctx->itChanged = false;
             break;
         }
-        printf("[movieplayer.cpp] vr=%d, ar=%d\n",vr,ar);
+
+      }
+      // Note: "itChanged" event will cause exit of the main reader
+      // loop to select another ts file with full reinitialzing 
+      // of the player thread (including FreezeAV/SoftReset) ...
+      break;
+
+    //-- not used --
+    //--------------
+    case CMoviePlayerGui::FF:
+    case CMoviePlayerGui::REW:
+      g_playstate = CMoviePlayerGui::PLAY;
+      break;
+
+    //-- jump forward/back --
+    //-----------------------
+    case CMoviePlayerGui::JF:
+    case CMoviePlayerGui::JB:
+      g_playstate = CMoviePlayerGui::PLAY;
+      
+      //-- (live) stream won't jump via seek --
+      if (ctx->isStream) break;
+
+      //-- freeze AV --
+      mp_freezeAV(ctx);
+       
+      //-- set new file position --
+      switch (g_jumpminutes)
+      {
+        case PF_JMP_START:
+	  ctx->pos = 0;
+          break;
+
+        case PF_JMP_MID:
+          ctx->pos = ctx->fileSize/2;
+          break;
+
+        case PF_JMP_END:
+	  ctx->pos = ctx->pos = ctx->fileSize - PF_SKPOS_OFFS; 
+          break;
+
+        default:
+          ctx->pos += (g_jumpminutes * (MINUTEOFFSET/PF_JMP_DIV));
+          break;
+      }
+
+      //-- check limits --
+      if (ctx->pos >= ctx->fileSize) ctx->pos = ctx->fileSize - PF_SKPOS_OFFS;
+      if (ctx->pos < ((off_t)0)) ctx->pos = (off_t)0;
+       
+      //-- jump to desired file position --  
+      ctx->pos = mp_seekSync(ctx->inFd, ctx->pos);
+      fprintf(stderr,"[mp] jump to pos (%lld) of total (%lld)\n", 
+              ctx->pos, ctx->fileSize);
+
+      //-- Note: the following "SoftReset" call will --
+      //-- initiate a restart of all DVB devices.    --
+      mp_softReset(ctx);
+      break;
+     
+    //-- soft reset --
+    //----------------
+    case CMoviePlayerGui::SOFTRESET:
+      g_playstate = CMoviePlayerGui::PLAY;
+      mp_softReset(ctx);
+      break;
+
+    //-- resync A/V --
+    //----------------
+    case CMoviePlayerGui::RESYNC:
+      g_playstate = CMoviePlayerGui::PLAY;
+      //mp_resync(ctx);
+      break;
+
+
+    //-- select audio track --
+    //------------------------
+    case CMoviePlayerGui::AUDIOSELECT:
+      g_playstate = CMoviePlayerGui::PLAY;
+      
+      //-- (live) stream should have 1 atrack only --
+      if (ctx->isStream) break;
+
+      mp_analyze(ctx);
+      fprintf(stderr, "[mp] using pida: 0x%04X ; pidv: 0x%04X ; ac3: %d\n",
+              ctx->pida, ctx->pidv, ctx->ac3);
+
+      mp_softReset(ctx);
+      
+      break;
+
+    //-- other --
+    //-----------
+    case CMoviePlayerGui::STOPPED:
+    case CMoviePlayerGui::PREPARING:
+    case CMoviePlayerGui::STREAMERROR:
+    case CMoviePlayerGui::PLAY:
+    case CMoviePlayerGui::SKIP:
+      break;
+  }
+
+  checkAspectRatio(ctx->vdec, false);
+}
+
+//== mp_read ==
+//=============
+/*
+static ssize_t mp_read(struct pollfd *pH, char *buf, size_t count, int tio)
+{
+  if ( (poll(pH, 1, tio) > 0) && (pH->events & pH->revents) )
+    return (read(pH->fd, buf, count));
+  else
+    return -1;
+}
+*/
+
+static ssize_t mp_tcpRead(struct pollfd *pH, char *buf, size_t count, int tio)
+{
+  ssize_t n, nleft = count;
+  
+  while ( (nleft>0) && (poll(pH, 1, tio) > 0) && (pH->events & pH->revents) )
+  {
+    n = read(pH->fd, buf, nleft);
+    nleft -= n;
+    buf   += n;
+  }  
+  
+  return (count-nleft);
+}
+
+//== mp_probe ==
+//==============
+#define MP_STREAM_MAGIC  "#DBOXSTREAM"
+#define MP_PLAYLST_MAGIC "#DBOXPLAYLST"
+
+static bool mp_probe(const char *fname, MP_CTX *ctx)
+{
+  FILE *fp;
+
+  ctx->isStream  = false; 
+  ctx->itChanged = false;
+  ctx->lst_cnt   = 0;
+  ctx->it        = 0;
+
+  if ( (fp = fopen(fname, "r")) == NULL ) 
+    return false; // error 
+  
+  if (fgets(ctx->dvrBuf, PF_BUF_SIZE-1, fp))
+  {
+    //-- check first line for magic value --
+    if (!memcmp(ctx->dvrBuf, MP_STREAM_MAGIC, sizeof(MP_STREAM_MAGIC)-1))
+    {
+      char *s1, *s2;
+      int  ntokens;
+      
+      //-- get all lines (quick and dirty parser) --
+      while (fgets(ctx->dvrBuf, PF_BUF_SIZE-1, fp))
+      {
+        if ( (s2 = strchr(ctx->dvrBuf,'#')) != NULL ) *s2 = '\0';
+        if ( strlen(ctx->dvrBuf) < 3 ) continue;
+
+        //-------------------------------------------------------------
+        //-- line format:                                            --
+        //-- "<progran name>=<ip>;<port>;<vpid>;<apid>;<zapto-id>\n" --
+        //-- example:                                                --
+        //--   PREMIERE1=dbox;31339;0x1ff;0x2ff;0x20085000a          --
+        //-- Note:                                                   -- 
+        //--   <zapto-id> can be "0" or "-1" to prevent zapping.     --
+        //--    with "-1" pause function will be enabled also.       --
+        //-------------------------------------------------------------
+        ntokens = 0;        
+
+        //-- program name --
+        s1 = ctx->dvrBuf;
+        if ((s2 = strchr(s1, '=')) != NULL )
+        {
+          ntokens++;
+          *s2 = '\0';
+          ctx->lst[ctx->lst_cnt].pname = s1;
+          s1 = s2+1;
+        }   
         
-		if (poll(pfd, 2, 0)) {
-			if (pfd[0].revents & POLLOUT) {
-				if ((awr = write(adec, &abuf[adone], ar)) < 0) {
-					if (errno != EAGAIN)
-						perror("audio write");
-				}
-				else {
-					ar -= awr;
-					adone += awr;
-				}
-			}
-			if (pfd[1].revents & POLLOUT) {
-				if ((vwr = write(vdec, &vbuf[vdone], vr)) < 0) {
-					perror("video write");
-				}
-				else {
-					vr -= vwr;
-					vdone += vwr;
-				}
-			}
-		}
-		checkAspectRatio(vdec, false);
-	}
+        //-- ip --
+        if ((s2 = strchr(s1, ';')) != NULL )
+        {
+          ntokens++;
+          *s2 = '\0';
+          ctx->lst[ctx->lst_cnt].ip = s1;
+          s1 = s2+1;
+        }
+        
+        //-- port (in dezimal) --
+        if ((s2 = strchr(s1, ';')) != NULL )
+        {
+          ntokens++;
+          *s2 = '\0';
+          ctx->lst[ctx->lst_cnt].port = strtol(s1, NULL, 10);
+          s1 = s2+1;
+        }   
+
+        //-- vpid (in hex) --
+        if ((s2 = strchr(s1, ';')) != NULL )
+        {
+          ntokens++;
+          *s2 = '\0';
+          ctx->lst[ctx->lst_cnt].vpid = strtol(s1, NULL, 16);
+          s1 = s2+1;
+        }   
+        
+        //-- apid (in hex) --
+        if ((s2 = strchr(s1, ';')) != NULL )
+        {
+          ntokens++;
+          *s2 = '\0';
+          ctx->lst[ctx->lst_cnt].apid = strtol(s1, NULL, 16);
+          s1 = s2+1;
+        }   
+        
+        //-- sid (in hex) --
+        if ((s2 = strchr(s1,'\n')) != NULL ) *s2 = '\0'; 
+        
+        ntokens++;
+        ctx->lst[ctx->lst_cnt].zapid = strtoll(s1, NULL, 16);
+          
+        if (ntokens == 6)
+          ctx->lst_cnt++;
+        else
+          fprintf(stderr, "[mp] parse error in livestream description\n");
+      
+        if (ctx->lst_cnt==PF_LST_ITEMS) break; // prevent overflow
+      }
+      
+      if (ctx->lst_cnt) ctx->isStream=true;
+    }
+    //-- ... or playlist --
+    else if (!memcmp(ctx->dvrBuf, MP_PLAYLST_MAGIC, sizeof(MP_PLAYLST_MAGIC)-1))
+    {
+      char *s2;
+      
+      while (fgets(ctx->dvrBuf, PF_BUF_SIZE-1, fp))
+      {
+        if ( (s2 = strchr(ctx->dvrBuf,'#')) != NULL ) *s2 = '\0';
+        if ( strlen(ctx->dvrBuf) < 3 ) continue;
+
+        if ( (s2 = strrchr(ctx->dvrBuf,'\n')) != NULL ) *s2 = '\0';
+        ctx->lst[ctx->lst_cnt].pname = ctx->dvrBuf;
+        ctx->lst_cnt++;
+        
+        if (ctx->lst_cnt==PF_LST_ITEMS) break; // prevent overflow
+      } 
+    }
+  }
+
+  fclose(fp);
+
+  if (ctx->lst_cnt)
+  {
+    fprintf(stderr, "[mp] %s with (%d) entries detected\n",
+            (ctx->isStream)?"(live)stream desc":"playlist", ctx->lst_cnt);
+  }
+    
+  return true;  
 
-	ioctl(vdec, VIDEO_STOP);
-	ioctl(adec, AUDIO_STOP);
-	close(vfile);
-	close(afile);
-	close(vdec);
-	close(adec);
-	
-	printf("[movieplayer.cpp] Stopped PES Playback\n");
-		
-	if (playstate != CMoviePlayerGui::STOPPED)
-	{
-		playstate = CMoviePlayerGui::STOPPED;
-		g_RCInput->postMsg (CRCInput::RC_red, 0);	// for faster exit in PlayStream(); do NOT remove!
-	}
+}
 
-	pthread_exit (NULL);
-	
+//== mp_analyze ==
+//================
+static void mp_analyze(MP_CTX *ctx)
+{
+#ifndef _MP_SIMULATOR
+  currentapid = 0;  // global
+  numpida     = 0;  // global
+
+  find_all_avpids (ctx->inFd, &(ctx->pidv), apids, ac3flags, &numpida);
+  //lseek(ctx->inFd, ctx->pos, SEEK_SET);
+  ctx->pos = mp_seekSync(ctx->inFd, ctx->pos);
+
+  for (int i=0; i<numpida; i++) 
+  {
+    fprintf(stderr, "[mp] found pida[%d]: 0x%04X, ac3=%d\n", 
+    i, apids[i], ac3flags[i]);
+  }
+  	    
+  if (numpida > 1) 
+  {
+    showaudioselectdialog = true;
+    while (showaudioselectdialog) usleep(50000);
+  }
+
+  if (!currentapid) 
+  {
+    ctx->pida   = apids[0];
+    ctx->ac3    = ac3flags[0];
+    
+    currentapid = ctx->pida;
+    currentac3  = ctx->ac3;
+  }
+  else
+  {
+    ctx->pida   = currentapid;
+    ctx->ac3    = currentac3;
+  }
+  
+  apidchanged = 0;
+  
+#else
+  find_avpids (ctx->inFd, &(ctx->pidv), &(ctx->pida));
+  lseek(ctx->inFd, 0L, SEEK_SET);
+  
+  ctx->ac3 = is_audio_ac3(ctx->inFd);
+#endif      
+}
+
+//== TCP I/O ==
+//=============
+static int mp_tcpRequest(int fd,char *ioBuf, int maxLen)
+{
+  int r;
+  
+  write(fd, ioBuf, strlen(ioBuf));
+  r = read(fd, ioBuf, maxLen);
+  if (r >= 0) ioBuf[r] = '\0';
 
+  return r;
 }
 
-	
-//------------------------------------------------------------------------
-void *
-PlayFileThread (void *filename)
+static int mp_tcpOpen(const char *serverIp, unsigned short serverPort)
 {
-	struct dmx_pes_filter_params p;
-	bool failed = false;
-	unsigned char buf[384 * 188 * 2];
-	unsigned short pida = 0, pidv = 0, ac3=0;
-	int done, fd=-1, dmxa=-1, dmxv = -1, dvr = -1, adec = -1, vdec = -1;
-	ssize_t wr = 0;
-	ssize_t cache = sizeof (buf);
-	size_t r = 0;
-	
-	if ((char *) filename == NULL)
-	{
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+  struct sockaddr_in ads;
+  socklen_t          adsLen;
+  int                fd;
+   
+  //-- tcp server (dbox) --
+  //-----------------------
+  bzero((char *)&ads, sizeof(ads));
+  ads.sin_family      = AF_INET;
+  ads.sin_addr.s_addr = inet_addr(serverIp);
+  ads.sin_port        = htons(serverPort);
+  adsLen              = sizeof(ads);
+
+  //-- get socket and try connect --
+  //--------------------------------
+  if ( (fd = socket(AF_INET, SOCK_STREAM, 0)) != -1)
+  {
+    if ( connect(fd, (struct sockaddr *)&ads, adsLen) == -1 )
+    {
+      close(fd); 
+      fd = -1;
+    }  
+  }
+  
+  return fd;
+}  
 
-	if ((fd = open ((const char *) filename, O_RDONLY | O_LARGEFILE)) < 0)
-	{
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+static void mp_tcpClose(int fd)
+{
+  if (fd != -1) close(fd);
+}
 
-	// todo: check if file is valid ts or pes
-	if (isTS)
-	{
-		currentapid = 0;
-		numpida=0;
-		find_all_avpids (fd, &pidv, apids, ac3flags, &numpida);
-		lseek(fd, 0, SEEK_SET);
-		int i;
-	    for (i=0; i<numpida;i++) {
-    	    printf ("[movieplayer.cpp] found pida[%d]: 0x%04X, ac3=%d\n", i,apids[i],ac3flags[i]);
-	    }
-	    if (numpida > 1) {
-    	    showaudioselectdialog = true;
-    	    while (showaudioselectdialog) {
-        	    if (playstate < CMoviePlayerGui::PLAY) {
-            	    // can actually never happen
-            	    close(fd);
-            	    pthread_exit (NULL);
-        	    }
-        	    usleep(100);
-    	    }
-	    }
-
-	    if (currentapid != 0) {
-    	    pida = currentapid;
-	        ac3 = currentac3;
-	        apidchanged = 0;
+//== mp_playFileThread ==
+//=======================
+void *mp_playFileThread (void *filename)
+{
+  std::string   fname  = (const char *)filename;
+  bool          failed = true;
+  struct pollfd pHandle;
+  int           rd, rSize;
+
+  MP_CTX mpCtx;
+  MP_CTX *ctx = &mpCtx;
+    
+  //-- initial setups --
+  //--------------------
+  ctx->pos = 0L;
+  fprintf(stderr, "[mp] PlayFileThread starts\n");
+
+  //-- open DVB devices --
+  //----------------------
+  if (mp_openDVBDevices(ctx))
+  {
+    //-- check for valid filename --
+    //------------------------------
+    if (fname.length())
+    {
+      //-- check for file type --
+      //-------------------------
+      if ( mp_probe(fname.c_str(), ctx) )
+        failed = false;
+      else
+        fprintf(stderr,"[mp] couldn't open (%s) for probing\n", fname.c_str());
+    }
+    else
+      fprintf(stderr,"[mp] invalid filename (null)\n");
+  }
+  else  
+    fprintf(stderr,"[mp] error opening some DVB devices\n");
+
+  
+  //-- terminate on error --
+  //------------------------
+  if (failed)
+  {
+    fprintf(stderr, "[mp] mp_playFileThread terminated\n");
+    g_playstate = CMoviePlayerGui::STOPPED;
+    mp_closeDVBDevices(ctx);
+    pthread_exit(NULL);
+  }
+  
+  do
+  {
+    //-- (live) stream or ... --
+    //--------------------------  
+    if (ctx->isStream)
+    {
+      MP_LST_ITEM *lstIt = &(ctx->lst[ctx->it]);
+
+      ctx->canPause = false;
+      
+      //-- file stream (timeshift) --
+      if (lstIt->zapid < 0)
+        ctx->canPause = true;
+      //-- tv live stream --
+      else if (lstIt->zapid > 0)
+      {
+        int zapFd;
+
+        //-- connect to dbox http-server --
+        if ( (zapFd = mp_tcpOpen(lstIt->ip.c_str(), 80)) != -1 )
+        {
+          //-- request zapping -- 
+          sprintf
+          (
+            ctx->dvrBuf,
+            "GET /control/zapto?0x%llx HTTP/1.0\r\n", 
+            lstIt->zapid
+          );
+
+          fprintf(stderr, "[mp] zap: %s\n", ctx->dvrBuf);
+          mp_tcpRequest(zapFd, ctx->dvrBuf, 512);
+ 
+          mp_tcpClose(zapFd);
         }
-        else {
-            pida = apids[0];
-            ac3 = ac3flags[0];
-            apidchanged = 0;
-            currentapid = pida;
+      }
+      usleep(250000);  
+      
+      //-- connect to (dbox) ts stream server --
+      if ( (ctx->inFd = mp_tcpOpen(lstIt->ip.c_str(), lstIt->port)) != -1 )
+      {
+        //-- send command line (vpid/apid) --
+        sprintf
+        (
+          ctx->dvrBuf, 
+          "GET /0x%03x,0x%03x HTTP/1.0\r\n", 
+          lstIt->vpid, lstIt->apid
+        );
+
+        mp_tcpRequest(ctx->inFd, ctx->dvrBuf, 512);
+        if ( strstr(ctx->dvrBuf, "200 OK") == NULL )
+        {
+          mp_tcpClose(ctx->inFd);
+          ctx->inFd = -1;
+          break; // error
         }
         
-	    printf ("[movieplayer.cpp] using pida: 0x%04X ; pidv: 0x%04X ; ac3: %d\n",
-		    pida, pidv, ac3);
-	}
-	else
-	{				// Play PES
-		pida = 0x900;
-		pidv = 0x8ff;
-	}
+        ctx->pidv     = lstIt->vpid;
+        ctx->pida     = lstIt->apid;
+        ctx->ac3      = 0;
+      
+        ctx->readSize = PF_BUF_SIZE/2;
+      }
+      else
+      {
+        fprintf(stderr, "error: connecting %s:%d\n", 
+                lstIt->ip.c_str(), lstIt->port );
+        break; // error
+      }
+    }
+    //-- ... plain TS file (playlist) --
+    //----------------------------------
+    else
+    {
+      if (ctx->lst_cnt) fname = ctx->lst[ctx->it].pname.c_str();
+    
+      if ( (ctx->inFd = open(fname.c_str(), O_RDONLY | O_LARGEFILE)) < 0 )
+      {
+        fprintf(stderr,"[mp] couldn't open (%s)\n", fname.c_str());
+        break; // error
+      }
+
+      ctx->canPause = true;
+      
+      //-- set (short) readsize --
+      ctx->readSize = PF_BUF_SIZE/4;
 
-	lseek (fd, 0L, SEEK_SET);
-	if ((dmxa = open (DMX, O_RDWR)) < 0
-	    || (dmxv = open (DMX, O_RDWR)) < 0
-	    || (dvr = open (DVR, O_WRONLY)) < 0
-	    || (adec = open (ADEC, O_RDWR)) < 0 || (vdec = open (VDEC, O_RDWR)) < 0)
-	{
-		failed = true;
-	}
+      //-- analyze TS file (set apid/vpid/ac3 in ctx) --
+      mp_analyze(ctx);
+  
+      //-- get file size --
+      ctx->fileSize = lseek (ctx->inFd, 0L, SEEK_END);
 
-	p.input = DMX_IN_DVR;
-	p.output = DMX_OUT_DECODER;
-	p.flags = DMX_IMMEDIATE_START;
-	p.pid = pida;
-	p.pes_type = DMX_PES_AUDIO;
-	if (ioctl (dmxa, DMX_SET_PES_FILTER, &p) < 0)
-		failed = true;
-	p.pid = pidv;
-	p.pes_type = DMX_PES_VIDEO;
-	if (ioctl (dmxv, DMX_SET_PES_FILTER, &p) < 0)
-		failed = true;
-	
-	checkAspectRatio(vdec, true);
-	
-	fileposition = startposition;
-	lseek (fd, fileposition, SEEK_SET);
-	if (isTS && !failed)
-	{
-		int mincache_counter = 0;
-		bool skipwriting = false;
-		while ((r = read (fd, buf, cache)) > 0 && playstate >= CMoviePlayerGui::PLAY)
-		{
-			done = 0;
-			wr = 0;
-			fileposition += r;
-			switch (playstate)
-			{
-			case CMoviePlayerGui::PAUSE:
-				while (playstate == CMoviePlayerGui::PAUSE)
-				{
-					ioctl (dmxa, DMX_STOP);
-				}
-				break;
-			case CMoviePlayerGui::FF:
-			case CMoviePlayerGui::REW:
-				ioctl (dmxa, DMX_STOP);
-                if (mincache_counter == 0) {
-                    lseek (fd, cache * speed, SEEK_CUR);
-                    fileposition += cache * speed;
-                }
-                mincache_counter ++;
-                if (mincache_counter == 2) {
-                    mincache_counter = 0;
-                }
-				break;
-			case CMoviePlayerGui::JF:
-			case CMoviePlayerGui::JB:
-				ioctl (dmxa, DMX_STOP);
-                lseek (fd, jumpminutes * MINUTEOFFSET, SEEK_CUR);
-                fileposition += jumpminutes * MINUTEOFFSET;
-                playstate = CMoviePlayerGui::SOFTRESET;
-                skipwriting = true;
-                break;
-			case CMoviePlayerGui::SOFTRESET:
-				ioctl (vdec, VIDEO_STOP);
-				ioctl (adec, AUDIO_STOP);
-				ioctl (dmxv, DMX_STOP);
-				ioctl (dmxa, DMX_STOP);
-				ioctl (vdec, VIDEO_PLAY);
-				if (ac3 == 1) {
-					ioctl (adec, AUDIO_SET_BYPASS_MODE,0UL);
-				}
-				else
-				{
-					ioctl (adec, AUDIO_SET_BYPASS_MODE,1UL);
-				}
-				ioctl (adec, AUDIO_PLAY);
-				p.pid = pida;
-				p.pes_type = DMX_PES_AUDIO;
-				ioctl (dmxa, DMX_SET_PES_FILTER, &p);
-				p.pid = pidv;
-				p.pes_type = DMX_PES_VIDEO;
-				ioctl (dmxv, DMX_SET_PES_FILTER, &p);
-				ioctl (dmxv, DMX_START);
-				ioctl (dmxa, DMX_START);
-				speed = 1;
-				playstate = CMoviePlayerGui::PLAY;
-				break;
-            case CMoviePlayerGui::AUDIOSELECT:
-        		numpida=0;
-        		find_all_avpids (fd, &pidv, apids, ac3flags, &numpida);
-        		lseek(fd, fileposition, SEEK_SET);
-        		int i;
-        	    for (i=0; i<numpida;i++) {
-            	    printf ("[movieplayer.cpp] found pida[%d]: 0x%04X, ac3=%d\n", i,apids[i],ac3flags[i]);
-        	    }
-        	    showaudioselectdialog = true;
-        	    while (showaudioselectdialog) {
-            	    if (playstate < CMoviePlayerGui::PLAY) {
-                	    // can actually never happen
-                	    //close(fd);
-                	    //pthread_exit (NULL);
-                	    break;
-            	    }
-            	    usleep(100);
-        	    }
+      //-- set bookmark position --
+      ctx->pos = g_startposition;
+      ctx->pos = mp_seekSync(ctx->inFd, ctx->pos);
+
+      g_startposition = 0;
+    }
+  
+    fprintf
+    (
+      stderr, 
+      "[mp] %s with vpid=(0x%04X) apid=(0x%04X) ac3=(%d)\n",
+      (ctx->isStream)?"(live) stream":"plain TS file",
+      ctx->pidv, ctx->pida, ctx->ac3
+    );
+
+    //-- DVB devices softreset --
+    //---------------------------
+    mp_softReset(ctx);  
+
+    //-- aspect ratio init --
+    checkAspectRatio(ctx->vdec, true);
+
+    //-- install poller --
+    pHandle.fd     = ctx->inFd;
+    pHandle.events = POLLIN | POLLPRI;
+    ctx->pH        = &pHandle;
+
+    //-- reader loop --
+    //-----------------
+    fprintf(stderr,"[mp] entering player loop\n");
+    while ( (ctx->itChanged == false) &&
+            (g_playstate >= CMoviePlayerGui::PLAY) )
+    {
+      //-- after device reset read double amount of stream data -- 
+      rSize = (ctx->refillBuffer)? ctx->readSize*2 : ctx->readSize;
+      ctx->refillBuffer = false;
+
+      if (ctx->isStream)
+        rd = mp_tcpRead(ctx->pH, ctx->dvrBuf, rSize, PF_RD_TIMEOUT);  
+      else
+        rd = read(ctx->inFd, ctx->dvrBuf, rSize);
+   
+      //-- update file position --
+      ctx->pos += rd;
+      g_fileposition = ctx->pos;
         
-        	    if (currentapid != 0) {
-            	    pida = currentapid;
-        	        ac3 = currentac3;
-        	        apidchanged = 0;
-                }
-                else {
-                    pida = apids[0];
-                    ac3 = ac3flags[0];
-                    apidchanged = 0;
-                    currentapid = pida;
-                }
-                
-        	    printf ("[movieplayer.cpp] using pida: 0x%04X ; pidv: 0x%04X ; ac3: %d\n",
-        		    pida, pidv, ac3);
-                    
-                playstate = CMoviePlayerGui::SOFTRESET;
-                break;
-			case CMoviePlayerGui::STOPPED:
-			case CMoviePlayerGui::PREPARING:
-			case CMoviePlayerGui::STREAMERROR:
-			case CMoviePlayerGui::PLAY:
-			case CMoviePlayerGui::RESYNC:
-			case CMoviePlayerGui::SKIP:
-				break;
-			}
+      //-- check break conditions and events --
+      if (rd != rSize) break;
+      mp_checkEvent(ctx);
+        
+      //-- after device reset skip writing --
+      //-- to refill buffer first ...      --
+      if (ctx->refillBuffer) continue;
+        
+      //-- after device reset, DMX devices --
+      //-- has to be started here ...      --
+      mp_startDMX(ctx); // starts only if stopped !
+ 
+      //-- write stream data now --
+      write(ctx->dvr, ctx->dvrBuf, rd);
+    } 
+      
+    fprintf(stderr,"[mp] leaving reader loop\n");
+
+    //-- close input stream --
+    //------------------------
+    if (ctx->inFd != -1)
+    {
+      if (ctx->isStream)
+      {
+        //-- disconnect from server --
+        mp_tcpClose(ctx->inFd);
+      }
+      else
+      {
+        //-- eventually activate autoplay for next file in a playlist --
+        if ( (ctx->itChanged == false) && ctx->lst_cnt ) 
+        {
+          ctx->it++;
+          if (ctx->it < ctx->lst_cnt) ctx->itChanged = true;
+        }
+        close(ctx->inFd);
+      }
 
-			if (!skipwriting) {
-    			do
-    			{
-    				wr = write (dvr, &buf[done], r);
-    				if (!done)
-    					cache = wr;
-    				done += wr;
-    				r -= wr;
-    			}
-    			while (r);
-			}
-			else skipwriting = false;
-			
-			checkAspectRatio(vdec, false);
-		}
-	}
-	else if (!failed)
-	{
-		ioctl (vdec, VIDEO_PLAY);
-		if (ac3 == 1) {
-			ioctl (adec, AUDIO_SET_BYPASS_MODE,0UL);
-		}
-		else
-		{
-			ioctl (adec, AUDIO_SET_BYPASS_MODE,1UL);
-		}
-		ioctl (adec, AUDIO_PLAY);
-		ioctl (dmxv, DMX_START);
-		ioctl (dmxa, DMX_START);
-		pes_to_ts2 (fd, dvr, pida, pidv, (const int *)&playstate);	// VERY bad performance!!!
-	}
+      ctx->inFd = -1;
+    }
+    
+    //-- Note: on any content change AV should be freezed first,   --
+    //-- to get a consitant state. restart of all DVB-devices will --
+    //-- be initiated by a SoftReset in the next turn/starts.      --
+    mp_freezeAV(ctx);
+
+    //-- check for another item to play --
+    //------------------------------------
+    if (g_playstate >= CMoviePlayerGui::PLAY && ctx->itChanged)
+    {
+      ctx->itChanged = false;
+      g_playstate    = CMoviePlayerGui::PLAY;
+
+      //updateLcd(ctx->lst[ctx->it].pname);
+    }
+    else
+      break; // normal loop exit
+
+  } while (1);
+ 
+  //-- stop and close DVB devices --
+  //--------------------------------
+  mp_closeDVBDevices(ctx);
+
+  //-- on exit after film end this will force any --
+  //-- action in ::PlayFile() - do not remove !   --
+  //------------------------------------------------
+  if (g_playstate != CMoviePlayerGui::STOPPED)
+  {
+    g_playstate = CMoviePlayerGui::STOPPED;
+    //g_RCInput->postMsg (CRCInput::RC_red, 0);	// end movieplayer
+    g_RCInput->postMsg (CRCInput::RC_ok, 0);	// start filebrowser 
+  }
 
-	ioctl (vdec, VIDEO_STOP);
-	ioctl (adec, AUDIO_STOP);
-	ioctl (dmxv, DMX_STOP);
-	ioctl (dmxa, DMX_STOP);
-	close (fd);
-	close (dmxa);
-	close (dmxv);
-	close (dvr);
-	close (adec);
-	close (vdec);
-	if (playstate != CMoviePlayerGui::STOPPED)
-	{
-		playstate = CMoviePlayerGui::STOPPED;
-		g_RCInput->postMsg (CRCInput::RC_red, 0);	// for faster exit in PlayStream(); do NOT remove!
-	}
+  fprintf(stderr, "[mp] mp_playFileThread terminated\n");
+  pthread_exit (NULL);
+}
 
-	pthread_exit (NULL);
+//=======================================
+//== CMoviePlayerGui::ParentalEntrance ==
+//=======================================
+#define CI_MAX 4
+
+void CMoviePlayerGui::ParentalEntrance(void)
+{
+  neutrino_msg_t      msg;
+  neutrino_msg_data_t data;
+
+  char code1[CI_MAX+1];
+  char code2[CI_MAX+1];
+  bool done = false;
+  int  ci   = 0;
+  
+  g_playstate = CMoviePlayerGui::STOPPED;
+  do
+  {
+    //-- check RC code --
+    //-------------------
+    g_RCInput->getMsg (&msg, &data, 10);  // 1 secs..
+    switch(msg)
+    {
+      case CRCInput::RC_0:
+      case CRCInput::RC_1:
+      case CRCInput::RC_2:
+      case CRCInput::RC_3:
+      case CRCInput::RC_4:
+      case CRCInput::RC_5:
+      case CRCInput::RC_6:
+      case CRCInput::RC_7:
+      case CRCInput::RC_8:
+      case CRCInput::RC_9:
+        code2[ci++] = msg - CRCInput::RC_1 + '1';
+        
+        if (ci>=CI_MAX)
+        {
+          int  n   = 0;
+          FILE *fp = NULL;
+
+          //-- get reference code from file (or set default "2222") -- 
+          if ( (fp = fopen("/var/tuxbox/config/mpcode","r")) != NULL )
+          {
+            n = fread(code1, 1, CI_MAX, fp);
+            fclose(fp);
+          }
+          if (n != CI_MAX) strcpy(code1,"2222");
+          
+          code1[CI_MAX] = '\0';
+          code2[CI_MAX] = '\0';
+          if (!strcmp(code1, code2))
+          {
+            fprintf(stderr, "[mp] pass ok!\n"); 
+            PlayFile(1);  
+          }
+          else
+          {  
+            //-- TODO: message box (see movieplayer help) --  
+            fprintf(stderr, "[mp] pass failed\n"); 
+          }
+          done = true;
+        }
+        break;
+
+      //-- Exit for Record/Zapto Timers  etc. --
+      case NeutrinoMessages::RECORD_START:
+      case NeutrinoMessages::ZAPTO:
+      case NeutrinoMessages::STANDBY_ON:
+      case NeutrinoMessages::SHUTDOWN:
+      case NeutrinoMessages::SLEEPTIMER:
+        g_RCInput->postMsg (msg, data);
+        done = true;
+        break;
+ 
+      default:
+        if (CNeutrinoApp::getInstance()->handleMsg(msg, data) & messages_return::cancel_all)
+          done = true;
+        break;
+    }
+  }
+  while ( done==false );
 }
 
+#ifndef _MP_SIMULATOR
+//===============================
+//== CMoviePlayerGui::PlayFile ==
+//===============================
+int CMoviePlayerGui::lastParental = -1;
 
-void updateLcd(const std::string & sel_filename)
+void CMoviePlayerGui::PlayFile (int parental)
 {
-	char tmp[20];
-	std::string lcd;
-	
-	switch(playstate)
-	{
-	case CMoviePlayerGui::PAUSE:
-		lcd = "|| (";
-		lcd += sel_filename;
-		lcd += ')';
-		break;
-	case CMoviePlayerGui::REW:
-		sprintf(tmp, "%dx<< ", speed);
-		lcd = tmp;
-		lcd += sel_filename;
-		break;
-	case CMoviePlayerGui::FF:
-		sprintf(tmp, "%dx>> ", speed);
-		lcd = tmp;
-		lcd += sel_filename;
-		break;
-	default:
-		lcd = "> ";
-		lcd += sel_filename;
-		break;
-	}
-	
-	CLCD::getInstance()->showServicename(lcd);
+  neutrino_msg_t      msg;
+  neutrino_msg_data_t data;
+
+  std::string sel_filename;
+  std::string hlpstr;
+
+  CTimeOSD    FileTime;
+  bool        update_lcd       = true;
+  bool        open_filebrowser = true;
+  bool        start_play       = false;
+  bool        requestStop      = false;
+  bool        rc_blocked       = false;
+  
+  g_playstate = CMoviePlayerGui::STOPPED;
+
+  //-- switch parental access via user definable script --
+  if (parental != lastParental)
+  {
+    fprintf(stderr,"[mp] setting parental to (%d)\n", parental);
+    lastParental = parental;
+
+    hlpstr = "/var/bin/parental.sh";
+    if (parental==1) hlpstr += " 1"; else hlpstr += " 0";
+    system(hlpstr.c_str());
+  }
+	 
+  do
+  {
+    //-- bookmark playback --
+    //-----------------------
+    if (isBookmark) 
+    {
+      open_filebrowser = false;
+      filename         = startfilename.c_str();
+      sel_filename     = startfilename;
+      update_lcd       = true;
+      start_play       = true;
+      isBookmark       = false;
+    }
+
+    //-- file browser --
+    //------------------
+    if (open_filebrowser)
+    {
+      open_filebrowser    = false;
+      filename            = NULL;
+      filebrowser->Filter = &tsfilefilter;
+
+      //-- play selected file or ... --
+      if (filebrowser->exec(Path_local.c_str()))
+      {
+        Path_local = filebrowser->getCurrentDir();
+        CFile *file;
+    
+        if ((file = filebrowser->getSelectedFile()) != NULL)
+        {
+          filename     = file->Name.c_str();
+          sel_filename = file->getFileName();
+          
+          update_lcd   = true;
+          start_play   = true;
+        }
+      }
+
+      //-- ... regular exit --
+      if (!start_play && (g_playstate == CMoviePlayerGui::STOPPED) )
+      { 
+        break; 
+      }
+
+      CLCD::getInstance()->setMode (CLCD::MODE_TVRADIO);
+    }
+
+    //-- LCD display --
+    //-----------------
+    if (update_lcd)
+    {
+      update_lcd = false;
+      updateLcd(sel_filename);
+    }
+
+    //-- start threaded playback --
+    //-----------------------------
+    if (start_play)
+    {
+      fprintf(stderr, "[mp] Startplay\n");
+      start_play = false;
+
+      if (g_playstate >= CMoviePlayerGui::PLAY)
+      {
+        //-- request player-thread to stop --
+        g_playstate = CMoviePlayerGui::STOPPED; 
+        pthread_join (rct, NULL);
+      }
+
+      //-- create player thread in PLAY mode --
+      g_playstate = CMoviePlayerGui::PLAY;  // !!!
+      if (pthread_create(&rct, 0, mp_playFileThread, (void *)filename) != 0)
+      {
+        fprintf(stderr, "[mp] couldn't create player thread\n");
+
+        //-- regular error exit, no need to wait for termination  --
+        g_playstate = CMoviePlayerGui::STOPPED;
+        break;  
+      }
+    }
+
+    //-- audio track selector                  --
+    // input:  numpida                         --
+    //         ac3flags[numpida]               --
+    //         currentapid = 0                 --
+    // ouptut: currentapid (may be remain 0,   --
+    //           if nothing happened)          -- 
+    //         currentac3                      --
+    //         apidchanged (0/1, but not used) --
+    //-------------------------------------------
+    if (showaudioselectdialog) 
+    {
+      CMenuWidget APIDSelector(LOCALE_APIDSELECTOR_HEAD, "audio.raw", 300);
+      APIDSelector.addItem(GenericMenuSeparator);
+      apidchanged = 0;
+
+      CAPIDSelectExec *APIDChanger = new CAPIDSelectExec;
+
+      for( unsigned int count=0; count<numpida; count++ )
+      {
+        char apidnumber[3];
+        sprintf(apidnumber, "%d", count+1);
+
+        std::string apidtitle = "Stream ";
+        apidtitle.append(apidnumber);
+  
+        if (ac3flags[count]) apidtitle.append(" (AC3)");
+              
+         APIDSelector.addItem
+         (
+           new CMenuForwarderNonLocalized
+           (
+             apidtitle.c_str(), true, NULL, APIDChanger, apidnumber, 
+             CRCInput::convertDigitToKey(count+1)
+           ), 
+           (count == 0)
+         );
+      }
+
+      APIDSelector.exec(NULL, "");
+      showaudioselectdialog = false;
+    }
+
+    //-- filetime display -- 
+    //----------------------
+    if(FileTime.IsVisible())
+    {
+      FileTime.update();
+    }
+
+    //-- check RC code --
+    //-------------------
+    g_RCInput->getMsg (&msg, &data, 10);  // 1 secs..
+    switch(msg)
+    {
+      //-- terminate player --
+      case CRCInput::RC_red:
+	requestStop = true;
+	break;
+      
+      //-- stop playback + start filebrowser --
+      case CRCInput::RC_home:
+        g_playstate = CMoviePlayerGui::STOPPED;
+	pthread_join(rct, NULL);
+        open_filebrowser = true;
+        break;
+
+      //-- pause / play --
+      case CRCInput::RC_yellow:
+        if (rc_blocked == false) // prevent to fast repeats
+        {
+          update_lcd  = true;
+          g_playstate = (g_playstate == CMoviePlayerGui::PAUSE) ? CMoviePlayerGui::PLAY : CMoviePlayerGui::PAUSE;
+          rc_blocked  = true;
+        }
+        break;
+
+      //-- invoke bookmark manager --
+      case CRCInput::RC_blue:
+        if (bookmarkmanager->getBookmarkCount() < bookmarkmanager->getMaxBookmarkCount())
+        {
+          char timerstring[200];
+          fprintf(stderr, "fileposition: %lld\n",g_fileposition);
+          sprintf(timerstring, "%lld",g_fileposition);
+          fprintf(stderr, "timerstring: %s\n",timerstring);
+          std::string bookmarktime = "";
+          bookmarktime.append(timerstring);
+          fprintf(stderr, "bookmarktime: %s\n",bookmarktime.c_str());
+          bookmarkmanager->createBookmark(filename, bookmarktime);
+        }
+        else
+        {
+          fprintf(stderr, "too many bookmarks\n");
+          DisplayErrorMessage(g_Locale->getText(LOCALE_MOVIEPLAYER_TOOMANYBOOKMARKS)); // UTF-8
+        }
+        break;
+
+      //-- request for audio selector --
+      case CRCInput::RC_green:
+        update_lcd  = true;
+        g_playstate = CMoviePlayerGui::AUDIOSELECT;
+        break;
+
+      //-- Help --
+      case CRCInput::RC_help:
+        hlpstr = g_Locale->getText(LOCALE_MOVIEPLAYER_TSHELP);
+        hlpstr += "\nVersion: $Revision: 1.1 $\n\nMovieplayer (c) 2003, 2004 by gagga";
+        ShowMsgUTF(LOCALE_MESSAGEBOX_INFO, hlpstr.c_str(), CMessageBox::mbrBack, CMessageBox::mbBack, "info.raw"); // UTF-8
+        break;
+
+      //-- filetime on/off --
+      case CRCInput::RC_setup:
+        if(FileTime.IsVisible())
+          FileTime.hide();
+        else
+          FileTime.show(g_fileposition / (MINUTEOFFSET/60));
+        break;
+
+      //-- jump 1/4 minute back --
+      case CRCInput::RC_left:
+        g_jumpminutes = -1;
+        g_playstate   = CMoviePlayerGui::JB;
+        update_lcd    = true;
+        FileTime.hide();
+        break;
+
+      //-- jump 1/4 minute forward --
+      case CRCInput::RC_right:
+        g_jumpminutes = 1;
+        g_playstate   = CMoviePlayerGui::JF;
+        update_lcd    = true;
+        FileTime.hide();
+        break;
+
+      //-- Resync A/V --
+      case CRCInput::RC_0:
+        if (g_playstate != CMoviePlayerGui::PAUSE)
+          //g_playstate = CMoviePlayerGui::RESYNC;
+          g_playstate = CMoviePlayerGui::SOFTRESET;
+        break;
+
+      //-- jump 1 minute back --
+      case CRCInput::RC_1:
+        g_jumpminutes = -1 * PF_JMP_DIV;
+        g_playstate   = CMoviePlayerGui::JB;
+        update_lcd    = true;
+        FileTime.hide();
+        break;
+
+      //-- jump to start --
+      case CRCInput::RC_2:
+        g_jumpminutes = PF_JMP_START;
+        g_playstate   = CMoviePlayerGui::JB;
+        update_lcd    = true;
+        FileTime.hide();
+        break;
+
+      //-- jump 1 minute forward --    
+      case CRCInput::RC_3:
+        g_jumpminutes = 1 * PF_JMP_DIV;
+        g_playstate   = CMoviePlayerGui::JF;
+        update_lcd    = true;
+        FileTime.hide();
+        break;
+
+      //-- jump 5 minutes back --
+      case CRCInput::RC_4:
+        g_jumpminutes = -5 * PF_JMP_DIV;
+        g_playstate = CMoviePlayerGui::JB;
+        update_lcd = true;
+        FileTime.hide();
+        break;
+
+      //-- jump to middle --
+      case CRCInput::RC_5:
+        g_jumpminutes = PF_JMP_MID;  // dirty hack 1
+        g_playstate = CMoviePlayerGui::JF;
+        update_lcd = true;
+        FileTime.hide();
+        break;
+
+      //-- jump 5 minutes forward --
+      case CRCInput::RC_6:
+        g_jumpminutes = 5 * PF_JMP_DIV;
+        g_playstate   = CMoviePlayerGui::JF;
+        update_lcd    = true;
+        FileTime.hide();
+        break;
+
+      //-- jump 10 minutes back -- 
+      case CRCInput::RC_7:
+        g_jumpminutes = -10 * PF_JMP_DIV;
+        g_playstate   = CMoviePlayerGui::JB;
+        update_lcd    = true;
+        FileTime.hide();
+        break;
+
+      //-- jump to end --
+      case CRCInput::RC_8:
+        g_jumpminutes = PF_JMP_END;  // dirty hack 2
+        g_playstate = CMoviePlayerGui::JF;
+        update_lcd = true;
+        FileTime.hide();
+        break;
+
+      //-- jump 10 minutes back --
+      case CRCInput::RC_9:
+        g_jumpminutes = 10 * PF_JMP_DIV;
+        g_playstate   = CMoviePlayerGui::JF;
+        update_lcd    = true;
+        FileTime.hide();
+        break;
+
+      //-- select previous item (in playlist) --  
+      case CRCInput::RC_up:
+        g_playstate = CMoviePlayerGui::ITEMSELECT;
+        g_itno      = -2;
+        break;
+
+      //-- select next item (in playlist) --
+      case CRCInput::RC_down:
+        g_playstate = CMoviePlayerGui::ITEMSELECT;
+        g_itno      = -1;
+        break;
+
+      //-- stop navigation action in progress (not used) --
+      //-- or start filebrowser while playing ...        --
+      case CRCInput::RC_ok:
+        if (g_playstate > CMoviePlayerGui::PLAY)
+        {
+          update_lcd = true;
+          g_playstate = CMoviePlayerGui::SOFTRESET;
+        }
+        else
+          open_filebrowser = true;
+        break;
+
+      //-- urgent exit for Record/Zapto Timers --
+      case NeutrinoMessages::RECORD_START:
+      case NeutrinoMessages::ZAPTO:
+      case NeutrinoMessages::STANDBY_ON:
+      case NeutrinoMessages::SHUTDOWN:
+      case NeutrinoMessages::SLEEPTIMER:
+        fprintf(stderr,"[mp] teminating due to high-prio event\n");
+        g_RCInput->postMsg (msg, data);
+        requestStop = true; // force exit
+        break;
+ 
+      default:
+        //-- force exit on cancel requests --
+        if (CNeutrinoApp::getInstance()->handleMsg(msg, data) & messages_return::cancel_all)
+        {
+          fprintf(stderr, "[mp] terminating due to cancel_all request\n");  
+          requestStop = true;  
+        }
+
+        rc_blocked = false;   
+        break;
+    }
+  }
+  while(requestStop==false);
+
+  //-- request stop only on a running player --
+  if (g_playstate >= CMoviePlayerGui::PLAY)
+  {
+    g_playstate = CMoviePlayerGui::STOPPED;
+    pthread_join(rct, NULL);
+  }
 }
+#endif
 
-//------------------------------------------------------------------------
+// ... GMO snip end
+
+
+//=================================
+//== CMoviePlayerGui::PlayStream ==
+//=================================
 #define SKIPPING_DURATION 3
 void
 CMoviePlayerGui::PlayStream (int streamtype)
@@ -1571,7 +2568,7 @@
 
 	}
 
-	playstate = CMoviePlayerGui::STOPPED;
+	g_playstate = CMoviePlayerGui::STOPPED;
 	/* playstate == CMoviePlayerGui::STOPPED         : stopped
 	 * playstate == CMoviePlayerGui::PREPARING       : preparing stream from server
 	 * playstate == CMoviePlayerGui::ERROR           : error setting up server
@@ -1588,9 +2585,9 @@
 		if (exit)
 		{
 			exit = false;
-			if (playstate >= CMoviePlayerGui::PLAY)
+			if (g_playstate >= CMoviePlayerGui::PLAY)
 			{
-				playstate = CMoviePlayerGui::STOPPED;
+				g_playstate = CMoviePlayerGui::STOPPED;
 				break;
 			}
 		}
@@ -1638,7 +2635,7 @@
 			}
 			else
 			{
-				if (playstate == CMoviePlayerGui::STOPPED)
+				if (g_playstate == CMoviePlayerGui::STOPPED)
 					break;
 			}
 
@@ -1657,9 +2654,9 @@
 			bufferfilled = false;
 			avpids_found=false;
 	  
-			if (playstate >= CMoviePlayerGui::PLAY)
+			if (g_playstate >= CMoviePlayerGui::PLAY)
 			{
-				playstate = CMoviePlayerGui::STOPPED;
+				g_playstate = CMoviePlayerGui::STOPPED;
 				pthread_join (rct, NULL);
 			}
 			//TODO: Add Dialog (Remove Dialog later)
@@ -1670,7 +2667,7 @@
 			{
 				break;
 			}
-			playstate = CMoviePlayerGui::SOFTRESET;
+			g_playstate = CMoviePlayerGui::SOFTRESET;
 		}
 
 		g_RCInput->getMsg (&msg, &data, 10);	// 1 secs..
@@ -1686,12 +2683,12 @@
 		else if (msg == CRCInput::RC_yellow)
 		{
 			update_info = true;
-			playstate = (playstate == CMoviePlayerGui::PAUSE) ? CMoviePlayerGui::SOFTRESET : CMoviePlayerGui::PAUSE;
+			g_playstate = (g_playstate == CMoviePlayerGui::PAUSE) ? CMoviePlayerGui::SOFTRESET : CMoviePlayerGui::PAUSE;
 			StreamTime.hide();
 		}
 		else if (msg == CRCInput::RC_green)
 		{
-			if (playstate == CMoviePlayerGui::PLAY) playstate = CMoviePlayerGui::RESYNC;
+			if (g_playstate == CMoviePlayerGui::PLAY) g_playstate = CMoviePlayerGui::RESYNC;
 			StreamTime.hide();
 		}
 		else if (msg == CRCInput::RC_blue)
@@ -1719,37 +2716,37 @@
 		else if (msg == CRCInput::RC_1)
 		{
 			skipvalue = "-00:01:00";
-			playstate = CMoviePlayerGui::SKIP;
+			g_playstate = CMoviePlayerGui::SKIP;
 			StreamTime.hide();
 		}
 		else if (msg == CRCInput::RC_3)
 		{
 			skipvalue = "+00:01:00";
-			playstate = CMoviePlayerGui::SKIP;
+			g_playstate = CMoviePlayerGui::SKIP;
 			StreamTime.hide();
 		}
 		else if (msg == CRCInput::RC_4)
 		{
 			skipvalue = "-00:05:00";
-			playstate = CMoviePlayerGui::SKIP;
+			g_playstate = CMoviePlayerGui::SKIP;
 			StreamTime.hide();
 		}
 		else if (msg == CRCInput::RC_6)
 		{
 			skipvalue = "+00:05:00";
-			playstate = CMoviePlayerGui::SKIP;
+			g_playstate = CMoviePlayerGui::SKIP;
 			StreamTime.hide();
 		}
 		else if (msg == CRCInput::RC_7)
 		{
 			skipvalue = "-00:10:00";
-			playstate = CMoviePlayerGui::SKIP;
+			g_playstate = CMoviePlayerGui::SKIP;
 			StreamTime.hide();
 		}
 		else if (msg == CRCInput::RC_9)
 		{
 			skipvalue = "+00:10:00";
-			playstate = CMoviePlayerGui::SKIP;
+			g_playstate = CMoviePlayerGui::SKIP;
 			StreamTime.hide();
 		}
 		else if (msg == CRCInput::RC_down)
@@ -1764,7 +2761,7 @@
 				skipvalue = tmp;
 				if(skipvalue[0]== '=')
 					skipvalue = skipvalue.substr(1);
-				playstate = CMoviePlayerGui::SKIP;
+				g_playstate = CMoviePlayerGui::SKIP;
 				StreamTime.hide();
 			}
 		}
@@ -1820,308 +2817,10 @@
 					exit = true;
 				}
 	}
-	while (playstate >= CMoviePlayerGui::PLAY);
+	while (g_playstate >= CMoviePlayerGui::PLAY);
 	pthread_join (rct, NULL);
 }
 
-void
-CMoviePlayerGui::PlayFile (void)
-{
-	neutrino_msg_t      msg;
-	neutrino_msg_data_t data;
-
-	std::string sel_filename;
-	CTimeOSD FileTime;
-	bool update_lcd = true, open_filebrowser =
-		true, start_play = false, exit = false;
-	playstate = CMoviePlayerGui::STOPPED;
-	/* playstate == CMoviePlayerGui::STOPPED         : stopped
-	 * playstate == CMoviePlayerGui::PLAY            : playing
-	 * playstate == CMoviePlayerGui::PAUSE           : pause-mode
-	 * playstate == CMoviePlayerGui::FF              : fast-forward
-	 * playstate == CMoviePlayerGui::REW             : rewind
-	 * playstate == CMoviePlayerGui::SOFTRESET       : softreset without clearing buffer (playstate toggle to 1)
-	 */
-	 
-	do
-	{
-		if (exit)
-		{
-			exit = false;
-			if (playstate >= CMoviePlayerGui::PLAY)
-			{
-				playstate = CMoviePlayerGui::STOPPED;
-				break;
-			}
-		}
-
-		if (isBookmark) 
-		{
-    	    open_filebrowser=false;
-    	    filename = startfilename.c_str();
-    	    sel_filename = startfilename;
-    	    update_lcd = true;
-			start_play = true;
-			isBookmark = false;
-
-    		
-		}
-		if (open_filebrowser)
-		{
-			open_filebrowser = false;
-			filename = NULL;
-			if (isTS)
-			{
-			    filebrowser->Filter = &tsfilefilter;
-		    }
-			else 
-			{
-    			if (isPES) {
-        			filebrowser->Filter = &pesfilefilter;
-    			}
-			}
-			if (filebrowser->exec(Path_local.c_str()))
-			{
-				Path_local = filebrowser->getCurrentDir();
-				CFile * file;
-				if ((file = filebrowser->getSelectedFile()) != NULL)
-				{
-					filename = file->Name.c_str();
-					update_lcd = true;
-					start_play = true;
-					sel_filename = filebrowser->getSelectedFile()->getFileName();
-				}
-			}
-			else
-			{
-				if (playstate == CMoviePlayerGui::STOPPED)
-					break;
-			}
-
-			CLCD::getInstance ()->setMode (CLCD::MODE_TVRADIO);
-		}
-
-		if (update_lcd)
-		{
-			update_lcd = false;
-			updateLcd(sel_filename);
-		}
-
-		if (start_play)
-		{
-			printf("Startplay\n");
-			start_play = false;
-			if (playstate >= CMoviePlayerGui::PLAY)
-			{
-				playstate = CMoviePlayerGui::STOPPED;
-				pthread_join (rct, NULL);
-			}
-
-			if (isTS) {
-			    if (pthread_create
-			        (&rct, 0, PlayFileThread, (void *) filename) != 0)
-			    {
-				    break;
-			    }
-			}
-			    
-			else {
-			    if (isPES && pthread_create
-			        (&rct, 0, PlayPESFileThread, (void *) filename) != 0)
-			    {
-				    break;
-			    }
-		    }
-			playstate = CMoviePlayerGui::SOFTRESET;
-		}
-
-		if (showaudioselectdialog) {
-			CMenuWidget APIDSelector(LOCALE_APIDSELECTOR_HEAD, "audio.raw", 300);
-			APIDSelector.addItem(GenericMenuSeparator);
-			apidchanged = 0;
-			CAPIDSelectExec *APIDChanger;
-			APIDChanger = new CAPIDSelectExec;
-			for( unsigned int count=0; count<numpida; count++ )
-			{
-				char apidnumber[3];
-				sprintf(apidnumber, "%d", count+1);
-				
-				std::string apidtitle = "Stream ";
-				apidtitle.append(apidnumber);
-				if (ac3flags[count]) {
-					apidtitle.append(" (AC3)");
-				}
-				
-				APIDSelector.addItem(new CMenuForwarderNonLocalized(apidtitle.c_str(), true, NULL, APIDChanger, apidnumber, CRCInput::convertDigitToKey(count+1)), (count == 0));
-			}
-			APIDSelector.exec(NULL, "");
-			if (currentapid == 0) {
-				currentapid = apids[0];
-				currentac3 = ac3flags[0];
-			}
-			showaudioselectdialog = false;
-		}
-        		
-		g_RCInput->getMsg (&msg, &data, 10);	// 1 secs..
-		if(FileTime.IsVisible())
-		{
-			FileTime.update();
-		}
-		if (msg == CRCInput::RC_red || msg == CRCInput::RC_home)
-		{
-			//exit play
-			exit = true;
-		}
-		else if (msg == CRCInput::RC_yellow)
-		{
-			update_lcd = true;
-			playstate = (playstate == CMoviePlayerGui::PAUSE) ? CMoviePlayerGui::SOFTRESET : CMoviePlayerGui::PAUSE;
-		}
-		else if (msg == CRCInput::RC_blue)
-		{
-			if (bookmarkmanager->getBookmarkCount() < bookmarkmanager->getMaxBookmarkCount())
-			{
-				char timerstring[200];
-				printf("fileposition: %lld\n",fileposition);
-				sprintf(timerstring, "%lld",fileposition);
-				printf("timerstring: %s\n",timerstring);
-				std::string bookmarktime = "";
-				bookmarktime.append(timerstring);
-				printf("bookmarktime: %s\n",bookmarktime.c_str());
-				bookmarkmanager->createBookmark(filename, bookmarktime);
-			}
-			else
-			{
-				printf("too many bookmarks\n");
-				DisplayErrorMessage(g_Locale->getText(LOCALE_MOVIEPLAYER_TOOMANYBOOKMARKS)); // UTF-8
-			}
-		}
-		else if (msg == CRCInput::RC_green)
-		{
-    		playstate = CMoviePlayerGui::AUDIOSELECT;
-        }
- 		else if (msg == CRCInput::RC_help)
- 		{
-			std::string fullhelptext = g_Locale->getText(LOCALE_MOVIEPLAYER_TSHELP);
-			fullhelptext += "\nVersion: $Revision: 1.1 $\n\nMovieplayer (c) 2003, 2004 by gagga";
-			ShowMsgUTF(LOCALE_MESSAGEBOX_INFO, fullhelptext.c_str(), CMessageBox::mbrBack, CMessageBox::mbBack, "info.raw"); // UTF-8
- 		}
- 		else if (msg == CRCInput::RC_setup)
- 		{
-			if(FileTime.IsVisible())
-			{
-				FileTime.hide();
-			}
-			else
-			{
-				FileTime.show(fileposition / (MINUTEOFFSET/60));
-			}
- 		}
-		else if (msg == CRCInput::RC_left)
-		{
-			// rewind
-			if (speed > 1)
-				speed = 1;
-			speed *= -2;
-			speed *= (speed > 1 ? -1 : 1);
-			playstate = CMoviePlayerGui::REW;
-			update_lcd = true;
-			FileTime.hide();
-		}
-		else if (msg == CRCInput::RC_right)
-		{
-			// fast-forward
-			if (speed < 1)
-				speed = 1;
-			speed *= 2;
-			playstate = CMoviePlayerGui::FF;
-			update_lcd = true;
-			FileTime.hide();
-		}
-		else if (msg == CRCInput::RC_1)
-		{
-			// Jump Backwards 1 minute
-			jumpminutes = -1;
-			playstate = CMoviePlayerGui::JB;
-			update_lcd = true;
-			FileTime.hide();
-		}
-		else if (msg == CRCInput::RC_3)
-		{
-			// Jump Forward 1 minute
-			jumpminutes = 1;
-			playstate = CMoviePlayerGui::JF;
-			update_lcd = true;
-			FileTime.hide();
-		}
-		else if (msg == CRCInput::RC_4)
-		{
-			// Jump Backwards 5 minutes
-			jumpminutes = -5;
-			playstate = CMoviePlayerGui::JB;
-			update_lcd = true;
-			FileTime.hide();
-		}
-		else if (msg == CRCInput::RC_6)
-		{
-			// Jump Forward 5 minutes
-			jumpminutes = 5;
-			playstate = CMoviePlayerGui::JF;
-			update_lcd = true;
-			FileTime.hide();
-		}
-		else if (msg == CRCInput::RC_7)
-		{
-			// Jump Backwards 10 minutes
-			jumpminutes = -10;
-			playstate = CMoviePlayerGui::JB;
-			update_lcd = true;
-			FileTime.hide();
-		}
-		else if (msg == CRCInput::RC_9)
-		{
-			// Jump Forward 10 minutes
-			jumpminutes = 10;
-			playstate = CMoviePlayerGui::JF;
-			update_lcd = true;
-			FileTime.hide();
-		}
-		else if (msg == CRCInput::RC_up || msg == CRCInput::RC_down)
-		{
-			// todo: next/prev file
-		}
-		else if (msg == CRCInput::RC_ok)
-		{
-			if (playstate > CMoviePlayerGui::PLAY)
-			{
-				update_lcd = true;
-				playstate = CMoviePlayerGui::SOFTRESET;
-			}
-			else
-				open_filebrowser = true;
-		}
-		else
-			if (msg == NeutrinoMessages::RECORD_START
-			    || msg == NeutrinoMessages::ZAPTO
-			    || msg == NeutrinoMessages::STANDBY_ON
-			    || msg == NeutrinoMessages::SHUTDOWN
-			    || msg == NeutrinoMessages::SLEEPTIMER)
-			{
-				// Exit for Record/Zapto Timers
-				isTS = true;		// also exit in PES Mode
-				exit = true;
-				g_RCInput->postMsg (msg, data);
-			}
-			else
-				if (CNeutrinoApp::getInstance()->handleMsg(msg, data) & messages_return::cancel_all)
-				{
-					isTS = true;		// also exit in PES Mode
-					exit = true;
-				}
-	}
-	while (playstate >= CMoviePlayerGui::PLAY);
-	pthread_join (rct, NULL);
-}
 
 // checks if AR has changed an sets cropping mode accordingly (only video mode auto)
 void checkAspectRatio (int vdec, bool init)
