--- movieplayer.cpp	Mon Jul 12 11:34:28 2004
+++ movieplayer.cpp	Mon Jul 12 11:52:21 2004
@@ -24,7 +24,6 @@
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
-
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
@@ -110,10 +109,10 @@
 #define MINUTEOFFSET 30898176
 	
 
-static CMoviePlayerGui::state playstate;
+static CMoviePlayerGui::state g_playstate;
 static bool isTS, isPES, isBookmark;
-int speed = 1;
-static long long fileposition;
+int g_speed = 1;
+static off_t g_fileposition;
 ringbuffer_t *ringbuf;
 bool bufferfilled;
 int streamingrunning;
@@ -125,8 +124,8 @@
 std::string startfilename;
 std::string skipvalue;
 
-long long startposition;
-int jumpminutes = 1;
+off_t g_startposition = 0L;
+int g_jumpminutes = 1;
 int buffer_time = 0;
 
 unsigned short apids[10];
@@ -168,24 +167,28 @@
 CMoviePlayerGui::CMoviePlayerGui()
 {
 	frameBuffer = CFrameBuffer::getInstance();
-	filebrowser = new CFileBrowser ();
-	filebrowser->Multi_Select = false;
+
+        if (strlen (g_settings.network_nfs_moviedir) != 0)
+	  Path_local = g_settings.network_nfs_moviedir;
+	else
+	  Path_local = "/";
+	Path_vlc  = "vlc://";
+	Path_vlc += g_settings.streaming_server_startdir;
+	Path_vlc_settings = g_settings.streaming_server_startdir;
+	
+        filebrowser = new CFileBrowser (Path_local);  // with filebrowser patch 
+	//filebrowser = new CFileBrowser();
+        filebrowser->Multi_Select = false;
 	filebrowser->Dirs_Selectable = false;
-	tsfilefilter.addFilter ("ts");
+	
+        tsfilefilter.addFilter ("ts");
 	vlcfilefilter.addFilter ("mpg");
 	vlcfilefilter.addFilter ("mpeg");
 	vlcfilefilter.addFilter ("m2p");
 	vlcfilefilter.addFilter ("avi");
 	vlcfilefilter.addFilter ("vob");
-	pesfilefilter.addFilter ("mpv");
-	filebrowser->Filter = &tsfilefilter;
-	if (strlen (g_settings.network_nfs_moviedir) != 0)
-		Path_local = g_settings.network_nfs_moviedir;
-	else
-		Path_local = "/";
-	Path_vlc  = "vlc://";
-	Path_vlc += g_settings.streaming_server_startdir;
-	Path_vlc_settings = g_settings.streaming_server_startdir;
+	
+        filebrowser->Filter = &tsfilefilter;
 }
 
 //------------------------------------------------------------------------
@@ -251,7 +254,7 @@
 
     isBookmark=false;
     startfilename = "";
-    startposition = 0;
+    g_startposition = 0;
     isTS=false;
     isPES=false;
     
@@ -269,14 +272,14 @@
         PlayFile();
 	}
 	else if (actionKey=="pesplayback") {
-        isPES=true;
-        PlayFile();
+        //isPES=true;
+        ParentalEntrance();
 	}
 	else if (actionKey=="bookmarkplayback") {
         isBookmark = true;
         if (theBookmark != NULL) {
             startfilename = theBookmark->getUrl();
-            sscanf (theBookmark->getTime(), "%lld", &startposition);
+            sscanf (theBookmark->getTime(), "%lld", &g_startposition);
             int vlcpos = startfilename.rfind("vlc://");
             if (vlcpos==0)
             {
@@ -355,7 +358,7 @@
 	if (httpres != 0)
 	{
 		DisplayErrorMessage(g_Locale->getText(LOCALE_MOVIEPLAYER_NOSTREAMINGSERVER)); // UTF-8
-		playstate = CMoviePlayerGui::STOPPED;
+		g_playstate = CMoviePlayerGui::STOPPED;
 		pthread_exit (NULL);
 		// Assume safely that all succeeding HTTP requests are successful
 	}
@@ -516,7 +519,7 @@
 	if (!VlcSendPlaylist((char*)mrl))
 	{
 		DisplayErrorMessage(g_Locale->getText(LOCALE_MOVIEPLAYER_NOSTREAMINGSERVER)); // UTF-8
-		playstate = CMoviePlayerGui::STOPPED;
+		g_playstate = CMoviePlayerGui::STOPPED;
 		pthread_exit (NULL);
 		// Assume safely that all succeeding HTTP requests are successful
 	}
@@ -577,7 +580,7 @@
 		if (connect(skt, (struct sockaddr *) &servAddr, sizeof (servAddr)) < 0)
 		{
 			perror ("SOCKET");
-			playstate = CMoviePlayerGui::STOPPED;
+			g_playstate = CMoviePlayerGui::STOPPED;
 			pthread_exit (NULL);
 		}
 		fcntl (skt, O_NONBLOCK);
@@ -589,7 +592,7 @@
 		if (send (skt, msg, msglen, 0) == -1)
 		{
 			perror ("send()");
-			playstate = CMoviePlayerGui::STOPPED;
+			g_playstate = CMoviePlayerGui::STOPPED;
 			pthread_exit (NULL);
 		}
 
@@ -643,7 +646,7 @@
 
 	while (streamingrunning == 1)
 	{
-		if (playstate == CMoviePlayerGui::STOPPED)
+		if (g_playstate == CMoviePlayerGui::STOPPED)
 		{
 			close(skt);
 			pthread_exit (NULL);
@@ -697,7 +700,7 @@
 			    ((poller[0].revents & (POLLHUP | POLLERR | POLLNVAL)) != 0))
 			{
 				perror ("Error while polling()");
-				playstate = CMoviePlayerGui::STOPPED;
+				g_playstate = CMoviePlayerGui::STOPPED;
 				close(skt);
 				pthread_exit (NULL);
 			}
@@ -723,12 +726,12 @@
 			}
 			else
 			{
-				if (playstate == CMoviePlayerGui::PLAY) {
+				if (g_playstate == CMoviePlayerGui::PLAY) {
 					nothingreceived++;
 					if (nothingreceived > (buffer_time + 3)*100) // wait at least buffer time secs +3 to play buffer when stream ends
 					{
 						printf ("[movieplayer.cpp] ReceiveStreamthread: Didn't receive for a while. Stopping.\n");
-						playstate = CMoviePlayerGui::STOPPED;	
+						g_playstate = CMoviePlayerGui::STOPPED;	
 					}
 					usleep(10000); //sleep 10 ms
 				}
@@ -784,7 +787,7 @@
 		failed = true;
 	}
 
-	playstate = CMoviePlayerGui::SOFTRESET;
+	g_playstate = CMoviePlayerGui::SOFTRESET;
 	printf ("[movieplayer.cpp] read starting\n");
 	size_t readsize, len;
 	len = 0;
@@ -797,7 +800,7 @@
 	
 	checkAspectRatio(vdec, true);
 	
-	while (playstate > CMoviePlayerGui::STOPPED)
+	while (g_playstate > CMoviePlayerGui::STOPPED)
 	{
 		readsize = ringbuffer_read_space (ringbuf);
 		if (readsize > MAXREADSIZE)
@@ -861,16 +864,16 @@
 
 			len = ringbuffer_read (ringbuf, buf, (readsize / 188) * 188);
 
-			if (startposition > 0) {
+			if (g_startposition > 0) {
 			    printf ("[movieplayer.cpp] Was Bookmark. Skipping to startposition\n");
 			    char tmpbuf[30];
-			    sprintf(tmpbuf,"%lld",startposition);
+			    sprintf(tmpbuf,"%lld",g_startposition);
 			    skipvalue = tmpbuf;
-			    startposition = 0;
-			    playstate = CMoviePlayerGui::SKIP;
+			    g_startposition = 0;
+			    g_playstate = CMoviePlayerGui::SKIP;
 			}
 
-			switch (playstate)
+			switch (g_playstate)
 			{
 			case CMoviePlayerGui::PAUSE:
 				//ioctl (dmxv, DMX_STOP);
@@ -879,7 +882,7 @@
 				// pause VLC
 	            httpres = sendGetRequest(pauseurl, response, false);
 
-				while (playstate == CMoviePlayerGui::PAUSE)
+				while (g_playstate == CMoviePlayerGui::PAUSE)
 				{
 					//ioctl (dmxv, DMX_STOP);	
 					//ioctl (dmxa, DMX_STOP);
@@ -887,7 +890,7 @@
 				}
 				// unpause VLC
 				httpres = sendGetRequest(unpauseurl, response, false);
-				speed = 1;
+				g_speed = 1;
 				break;
 			case CMoviePlayerGui::SKIP:
 			{
@@ -900,8 +903,8 @@
 				int bytes = (ringbuffer_read_space(ringbuf) / 188) * 188;
 				ringbuffer_read_advance(ringbuf, bytes);
 				httpres = sendGetRequest(skipurl, response, false);
-//				playstate = CMoviePlayerGui::RESYNC;
-				playstate = CMoviePlayerGui::PLAY;
+//				g_playstate = CMoviePlayerGui::RESYNC;
+				g_playstate = CMoviePlayerGui::PLAY;
 			}
 			break;
 			case CMoviePlayerGui::RESYNC:
@@ -917,7 +920,7 @@
 				bufferingBox->paint();
 				bufferfilled = false;
 				ioctl (dmxa, DMX_START);
-				playstate = CMoviePlayerGui::PLAY;
+				g_playstate = CMoviePlayerGui::PLAY;
 				break;
 			case CMoviePlayerGui::PLAY:
 				if (len < MINREADSIZE)
@@ -945,7 +948,7 @@
 						{
 							perror("[movieplayer.cpp] PlayStreamThread: write failed");
 #warning I have no clue except what to do if writing fails so I just set playstate to CMoviePlayerGui::STOPPED
-							playstate = CMoviePlayerGui::STOPPED;
+							g_playstate = CMoviePlayerGui::STOPPED;
 							break;
 						}
 						else
@@ -981,8 +984,8 @@
 				ioctl (dmxv, DMX_SET_PES_FILTER, &p);
 				ioctl (dmxv, DMX_START);
 				ioctl (dmxa, DMX_START);
-				speed = 1;
-				playstate = CMoviePlayerGui::PLAY;
+				g_speed = 1;
+				g_playstate = CMoviePlayerGui::PLAY;
 				break;
 			case CMoviePlayerGui::STOPPED:
 			case CMoviePlayerGui::PREPARING:
@@ -1028,508 +1031,1564 @@
 	pthread_exit (NULL);
 }
 
-//------------------------------------------------------------------------
-void *
-PlayPESFileThread (void *filename)
+//== updateLcd ==
+//===============
+void updateLcd(const std::string & sel_filename)
 {
-	struct pollfd pfd[2];
-	unsigned char abuf[188 * 188], vbuf[188 * 188];
-	const char *afilename, *vfilename;
-	int adec, vdec, afile, vfile;
-	ssize_t awr, vwr;
-	size_t ar = 0, vr = 0;
-	int adone = 0, vdone = 0;
-	unsigned int acaps, vcaps;
-
-	vfilename = (const char*) filename;
-	
-    std::string afilenametmp = vfilename;
-    afilenametmp = afilenametmp.substr(0,afilenametmp.length()-3);
-    afilenametmp += "mp2";
-    afilename = afilenametmp.c_str();
-	//afilename = "/mnt/movies/testfilm.mp2";
-	
-	printf("[movieplayer.cpp] Starting PES Playback\n");
-	printf("[movieplayer.cpp] vfile=%s\n",vfilename);
-	printf("[movieplayer.cpp] afile=%s\n",afilename);
+	char tmp[20];
+	std::string lcd;
 	
-	if ((adec = open(ADEC, O_WRONLY | O_NONBLOCK)) < 0) {
-		perror(ADEC);
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
+	switch(g_playstate)
+	{
+	case CMoviePlayerGui::PAUSE:
+		lcd = "|| (";
+		lcd += sel_filename;
+		lcd += ')';
+		break;
+	case CMoviePlayerGui::REW:
+		sprintf(tmp, "%dx<< ", g_speed);
+		lcd = tmp;
+		lcd += sel_filename;
+		break;
+	case CMoviePlayerGui::FF:
+		sprintf(tmp, "%dx>> ", g_speed);
+		lcd = tmp;
+		lcd += sel_filename;
+		break;
+	default:
+		lcd = "> ";
+		lcd += sel_filename;
+		break;
 	}
+	
+	CLCD::getInstance()->showServicename(lcd);
+}
 
-	if ((vdec = open(VDEC, O_WRONLY)) < 0) {
-		perror(VDEC);
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+// GMO snip start ...
 
-	if ((afile = open(afilename, O_RDONLY)) < 0) {
-		perror(afilename);
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+//=============================	
+//== PlayTSFile Thread Stuff ==
+//=============================
+#define PF_BUF_SIZE   (700*188)	// was 360
+#define PF_EMPTY      0
+#define PF_READY      1
+#define PF_LST_ITEMS  30
+#define PF_SKPOS_OFFS MINUTEOFFSET  
+
+//-- live stream item --
+//----------------------
+typedef struct 
+{
+  std::string        pname;
+  std::string        ip;
+  int                port;
+  int                vpid;
+  int                apid;
+  long long          zapid;
+
+} MP_LST_ITEM;
+
+//-- main player context --
+//-------------------------
+typedef struct
+{
+  pthread_mutex_t mtx0;
+  pthread_mutex_t mtx1;
+  pthread_mutex_t mtx2;
+  pthread_mutex_t mtx3;
+  
+  pthread_cond_t  cond;
+  pthread_t       wThread;
+  
+  struct dmx_pes_filter_params p;
+  short                        ac3;
+  unsigned short               pida;
+  unsigned short               pidv;
+
+  FILE  *inFp;
+  int   inFd;
+  int   dvr;
+  int   dmxv;
+  int   dmxa;
+  int   vdec;
+  int   adec;
+  
+  off_t pos;
+  off_t fileSize;
 
-	if ((vfile = open(vfilename, O_RDONLY)) < 0) {
-		perror(vfilename);
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+  int   readSize;  
+  char  buf[4][PF_BUF_SIZE];
+  int   r[4];
+  int   s[4];
+
+  bool  rdReset;
+  bool  wrReset;
+  bool  isWriting;
+  bool  isReading;
+
+  bool        isStream;
+  bool        itChanged;
+  bool        canPause;
+  int         it;
+  int         lst_cnt;
+  MP_LST_ITEM lst[PF_LST_ITEMS];
+
+} MP_CTX;
+
+//-- some bullshit global values --
+#ifndef _MP_SIMULATOR
+static int g_itno = 0;
+#endif
 
-	if (ioctl(adec, AUDIO_GET_CAPABILITIES, &acaps) < 0) {
-		perror("AUDIO_GET_CAPABILITIES");
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+static bool openDVBDevices(MP_CTX *ctx);
+static void closeDVBDevices(MP_CTX *ctx);
+static void PlayTSFileSoftReset(MP_CTX *ctx);
+static void PlayTSFileFreezeAV(MP_CTX *ctx, bool resetFlag);
+static void PlayTSFileCheckEvent(MP_CTX *ctx);
+static bool PlayTSFileWriterCreate(MP_CTX *ctx);
+static void *PlayTSFileWriterThread(void *_ctx);
+static bool PlayTSFileReadBuffers(MP_CTX *ctx);
+static bool PlayTSFileProbe(const char *fname, MP_CTX *ctx);
+static void PlayTSFileAnalyze(MP_CTX *ctx);
+
+//== open/close DVB devices ==
+//============================
+static bool openDVBDevices(MP_CTX *ctx)
+{
+  //-- may prevent black screen after restart ... --
+  //------------------------------------------------
+  usleep(150000);
+  
+  ctx->dmxa = -1;
+  ctx->dmxv = -1;
+  ctx->dvr  = -1;
+  ctx->adec = -1;
+  ctx->vdec = -1;
+
+  if ((ctx->dmxa = open(DMX, O_RDWR)) < 0
+       || (ctx->dmxv = open(DMX, O_RDWR)) < 0
+       || (ctx->dvr = open(DVR, O_WRONLY)) < 0
+       || (ctx->adec = open(ADEC, O_RDWR)) < 0 || (ctx->vdec = open(VDEC, O_RDWR)) < 0)
+  {  
+    return false;
+  }
+  return true;
+}
 
-	if (ioctl(vdec, VIDEO_GET_CAPABILITIES, &vcaps) < 0) {
-		perror("VIDEO_GET_CAPABILITIES");
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+static void closeDVBDevices(MP_CTX *ctx)
+{
+  //-- may prevent black screen after restart ... --
+  //------------------------------------------------
+  usleep(150000);
+
+  if (ctx->vdec != -1) 
+  {
+    ioctl (ctx->vdec, VIDEO_STOP);
+    close (ctx->vdec);
+  }
+  if (ctx->adec != -1) 
+  {
+    ioctl (ctx->adec, AUDIO_STOP);
+    close (ctx->adec);
+  }  
+  if (ctx->dmxa != -1) 
+  {
+    ioctl (ctx->dmxa, DMX_STOP);
+    close(ctx->dmxa);
+  }
+  if (ctx->dmxv != -1) 
+  {
+    ioctl (ctx->dmxv, DMX_STOP);
+    close(ctx->dmxv);
+  }
+  if (ctx->dvr!= -1) close(ctx->dvr);
+ 
+  ctx->dmxa = -1;
+  ctx->dmxv = -1;
+  ctx->dvr  = -1;
+  ctx->adec = -1;
+  ctx->vdec = -1;
+}
 
-	if (!(acaps & AUDIO_CAP_MP2)) {
-		fprintf(stderr, "audio decoder does not support mpeg2 pes\n");
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+//== PlayTSFileSoftReset ==
+//=========================
+static void PlayTSFileSoftReset(MP_CTX *ctx)
+{
+  //-- don't break active writing --
+  while (ctx->isWriting) usleep(5000);
+  
+  //-- stop DMX devices --
+  ioctl(ctx->dmxv, DMX_STOP);
+  ioctl(ctx->dmxa, DMX_STOP);
+
+  //-- stop AV devices --
+  ioctl(ctx->vdec, VIDEO_STOP);
+  ioctl(ctx->adec, AUDIO_STOP);
+
+  //-- setup DMX devices (again) --
+  ctx->p.input    = DMX_IN_DVR;
+  ctx->p.output   = DMX_OUT_DECODER;
+  ctx->p.flags    = 0; //DMX_IMMEDIATE_START;
+
+  ctx->p.pid      = ctx->pida;
+  ctx->p.pes_type = DMX_PES_AUDIO;
+  ioctl (ctx->dmxa, DMX_SET_PES_FILTER, &(ctx->p));
+
+  ctx->p.pid      = ctx->pidv;
+  ctx->p.pes_type = DMX_PES_VIDEO;
+  ioctl (ctx->dmxv, DMX_SET_PES_FILTER, &(ctx->p));
+
+  //-- start AV devices again --
+  if (ctx->ac3 == 1) 
+    ioctl(ctx->adec, AUDIO_SET_BYPASS_MODE,0UL);
+  else
+    ioctl(ctx->adec, AUDIO_SET_BYPASS_MODE,1UL);
+
+  ioctl(ctx->adec, AUDIO_PLAY);             // audio
+  ioctl(ctx->vdec, VIDEO_PLAY);             // video
+  ioctl(ctx->adec, AUDIO_SET_AV_SYNC, 1UL); // needs sync !
+  
+  //-- after buffer reset don't start demuxer here! --
+  //-- -> this will be done later in writer thread. --
+  if (!ctx->wrReset)
+  {
+    ioctl(ctx->dmxa, DMX_START);  // audio first !
+    ioctl(ctx->dmxv, DMX_START);
+  }
+}
 
-	if (!(vcaps & VIDEO_CAP_MPEG2)) {
-		fprintf(stderr, "video decoder does not support mpeg2 pes\n");
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+//== PlayTSFileCheckEvent ==
+//==========================
+static void PlayTSFileCheckEvent(MP_CTX *ctx)
+{
+  switch (g_playstate)
+  {
+    //-- Pause --
+    //-----------
+    case CMoviePlayerGui::PAUSE:
+      //-- live stream won't pause --
+      if (!ctx->canPause)
+      {
+        g_playstate = CMoviePlayerGui::PLAY;
+        break;
+      }
+
+      //-- Freeze AV with(!) buffer reset --
+      PlayTSFileFreezeAV(ctx, true);
+
+      fprintf(stderr, "[mp] pause\n");
+      while (g_playstate == CMoviePlayerGui::PAUSE) usleep(10000);
+      fprintf(stderr, "[mp] continue\n");
+      
+      //-- after unpause, a call to "SoftReset" --
+      //-- will restart all DVB devices again.  --
+      PlayTSFileSoftReset(ctx);
+      break;
+
+    //-- next item of program/play-list   --
+    //-------------------------------------- 
+    case CMoviePlayerGui::ITEMSELECT:
+      g_playstate = CMoviePlayerGui::PLAY;
+
+      //-- TODO: may be sometimes will it work for (live) streams --
+      if (ctx->isStream) break; // finish
+      
+      if (ctx->lst_cnt)
+      {
+        ctx->itChanged = true;
+        switch (g_itno)
+        {
+          //-- previous item --
+          case -2:
+            ctx->it -= 1;
+            if (ctx->it < 0) ctx->it = ctx->lst_cnt-1;
+            fprintf(stderr,"[mp] previous item [%d]\n", ctx->it);
+            break;
 
-	if (ioctl(adec, AUDIO_SELECT_SOURCE, AUDIO_SOURCE_MEMORY) < 0) {
-		perror("AUDIO_SELECT_SOURCE");
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+          //-- next item --
+          case -1:
+            ctx->it += 1;
+            if (ctx->it >= ctx->lst_cnt) ctx->it = 0;
+            fprintf(stderr, "[mp] next item [%d]\n", ctx->it);
+            break;
 
-	if (ioctl(vdec, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_MEMORY) < 0) {
-		perror("VIDEO_SELECT_SOURCE");
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+          //-- directly selected number --
+          default:
+            if (ctx->it != g_itno)
+            {
+              if (g_itno >= ctx->lst_cnt)
+                ctx->it = ctx->lst_cnt-1;
+              else
+                ctx->it = g_itno;
+              fprintf(stderr, "[mp] selecting item [%d]\n", ctx->it);
+            }
+            else
+              ctx->itChanged = false;
+            break;
+        }
 
-	if (ioctl(adec, AUDIO_SET_STREAMTYPE, AUDIO_CAP_MP2) < 0) {
-		perror("AUDIO_SET_STREAMTYPE");
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+      }
+      // Note: "itChanged" event will cause exit of the main reader
+      // loop to select another ts file with full reinitialzing 
+      // of the player thread (including FreezeAV/SoftReset) ...
+      break;
+
+    //-- not used --
+    //--------------
+    case CMoviePlayerGui::FF:
+    case CMoviePlayerGui::REW:
+      g_playstate = CMoviePlayerGui::PLAY;
+      break;
+
+    //-- jump forward/back --
+    //-----------------------
+    case CMoviePlayerGui::JF:
+    case CMoviePlayerGui::JB:
+      g_playstate = CMoviePlayerGui::PLAY;
+      
+      //-- (live) stream won't jump via seek --
+      if (ctx->isStream) break;
+
+      //-- freeze AV with(!) buffer reset --
+      PlayTSFileFreezeAV(ctx, true);
+       
+      //-- check limits --
+      ctx->pos += (g_jumpminutes * MINUTEOFFSET);
+      if (ctx->pos >= ctx->fileSize) ctx->pos = ctx->fileSize - PF_SKPOS_OFFS;
+      if (ctx->pos < ((off_t)0)) ctx->pos = (off_t)0;
+       
+      //-- jump to desired file position --  
+      lseek (ctx->inFd, ctx->pos, SEEK_SET);
+      fprintf(stderr,"[mp] jump to pos (%lld) of total (%lld)\n", 
+              ctx->pos, ctx->fileSize);
+
+      //-- Note: the following "SoftReset" call will --
+      //-- initiate a restart of all DVB devices.    --
+      PlayTSFileSoftReset(ctx);
+      break;
+     
+    //-- soft reset --
+    //----------------
+    case CMoviePlayerGui::SOFTRESET:
+      g_playstate = CMoviePlayerGui::PLAY;
+      //PlayTSFileFreezeAV(ctx, false/true???);
+      PlayTSFileSoftReset(ctx);
+      break;
+
+#ifndef _MP_SIMULATOR
+    //-- select audio track --
+    //------------------------
+    case CMoviePlayerGui::AUDIOSELECT:
+      g_playstate = CMoviePlayerGui::PLAY;
+      
+      //-- (live) stream should have 1 atrack only --
+      if (ctx->isStream) break;
+
+      PlayTSFileAnalyze(ctx);
+      fprintf(stderr, "[mp] using pida: 0x%04X ; pidv: 0x%04X ; ac3: %d\n",
+              ctx->pida, ctx->pidv, ctx->ac3);
+
+      PlayTSFileSoftReset(ctx);
+      
+      break;
+#endif
 
-	if (ioctl(vdec, VIDEO_SET_STREAMTYPE, VIDEO_CAP_MPEG2) < 0) {
-		perror("VIDEO_SET_STREAMTYPE");
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+    //-- other --
+    //-----------
+    case CMoviePlayerGui::STOPPED:
+    case CMoviePlayerGui::PREPARING:
+    case CMoviePlayerGui::STREAMERROR:
+    case CMoviePlayerGui::PLAY:
+    case CMoviePlayerGui::SKIP:
+    case CMoviePlayerGui::RESYNC:
+#ifdef _MP_SIMULATOR
+    case CMoviePlayerGui::AUDIOSELECT:
+#endif
+      break;
+  }
 
-	if (ioctl(adec, AUDIO_PLAY) < 0) {
-		perror("AUDIO_PLAY");
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+  checkAspectRatio(ctx->vdec, false);
+}
 
-	if (ioctl(vdec, VIDEO_PLAY) < 0) {
-		perror("VIDEO_PLAY");
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
-		
-	printf("[movieplayer.cpp] Starting PES Playback. All preparations done.\n");
-	
-	pfd[0].fd = afile;
-	pfd[0].events = POLLOUT;
-	pfd[1].fd = vfile;
-	pfd[1].events = POLLOUT;
+//== PlayTSFileWriterCreate ==
+//============================
+static bool PlayTSFileWriterCreate(MP_CTX *ctx)
+{
+  for (int i=0; i<4; i++)
+  {
+    ctx->s[i] = PF_EMPTY;
+    ctx->r[i] = 0;
+  }
+  
+  ctx->isWriting = false; // !
+  ctx->isReading = true;  // !
 
-	checkAspectRatio(vdec, true);
+  if ( pthread_create(&(ctx->wThread), NULL, PlayTSFileWriterThread, ctx) )
+  {  
+    fprintf(stderr,"[mp] couldn't create writer thread\n");
+    return false;
+  }
+
+  return true;
+} 
+
+//== PlayTSFileFreezeAV ==
+//========================
+static void PlayTSFileFreezeAV(MP_CTX *ctx, bool resetFlag)
+{
+  //-- freeze (pause) AV playback immediate --
+  ioctl(ctx->vdec, VIDEO_FREEZE);
+  ioctl(ctx->adec, AUDIO_PAUSE);
+ 
+  //-- reset r/w buffers on request -- 
+  if (resetFlag)
+  {
+    for (int i=0; i<4; i++) ctx->s[i] = PF_EMPTY;
+  
+    ctx->rdReset = true; // !
+    ctx->wrReset = true; // !
+  }
+  
+  //-- wait until writer has finished --
+  while (ctx->isWriting) usleep(5000);
+}
 
-	while (playstate >= CMoviePlayerGui::PLAY) {
-    		switch (playstate)
-			{
-			case CMoviePlayerGui::PAUSE:
-				while (playstate == CMoviePlayerGui::PAUSE)
-				{
-					usleep(100000); // no busy wait
-				}
-				break;
-			// ignore playstates.
-			// TODO: implement them
-			case CMoviePlayerGui::PREPARING:
-			case CMoviePlayerGui::STREAMERROR:
-			case CMoviePlayerGui::RESYNC:
-		    case CMoviePlayerGui::FF:
-			case CMoviePlayerGui::REW:
-			case CMoviePlayerGui::JF:
-			case CMoviePlayerGui::JB:
-			case CMoviePlayerGui::SOFTRESET:
-                playstate = CMoviePlayerGui::PLAY;
-				break;
-			case CMoviePlayerGui::PLAY:
-			case CMoviePlayerGui::STOPPED:
-			case CMoviePlayerGui::SKIP:
-			case CMoviePlayerGui::AUDIOSELECT:
-			    break;
-			}
+//== PlayTSFileWriterThread ==
+//============================
+static void *PlayTSFileWriterThread(void *_ctx)
+{
+  MP_CTX         *ctx = (MP_CTX *)_ctx; 
+  unsigned long  cntB = 0;
+  unsigned long  cntW = 0;
+ 
+  int  wr;
+
+  fprintf(stderr, "[mp] writer thread starts\n");
+
+  pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
+  pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
+
+  ctx->isWriting = true;
+  while (1)
+  {
+  
+  LB_WR_RESET:
+    
+    //-- write buffer 0 --
+    //--------------------
+    pthread_mutex_lock(&(ctx->mtx0));
+    {
+      if (ctx->s[0] != PF_READY)
+      { 
+        ctx->isWriting = false;
+        cntW++;
+        pthread_cond_wait(&(ctx->cond), &(ctx->mtx0));
+        ctx->isWriting = true;
+      }
+      
+      //-- after buffer reset, DMX devices has to be started here ! --
+      if (ctx->wrReset)
+      {
+        ctx->wrReset = false;
+        ioctl (ctx->dmxa, DMX_START); // audio first !
+        ioctl (ctx->dmxv, DMX_START);
+      }
+      
+      if (ctx->s[0] == PF_READY)
+      {
+        wr = write(ctx->dvr, ctx->buf[0], ctx->r[0]);
+        ctx->s[0] = PF_EMPTY;
+        cntB++;
+      }
+      pthread_cond_signal(&ctx->cond);
+    }  
+    pthread_mutex_unlock(&ctx->mtx0);
+    
+    if (!ctx->isReading) break; 
+    else if (ctx->wrReset) goto LB_WR_RESET;
 
-    	
-		if (ar <= 0) {
-			if ((ar = read(afile, abuf, sizeof(abuf))) < 0) {
-				perror("audio read");
-				playstate = CMoviePlayerGui::STOPPED;
-				break;
-			}
-			adone = 0;
-			printf("[movieplayer.cpp] adone=0\n");
-		}
-		if (vr <= 0) {
-			if ((vr = read(vfile, vbuf, sizeof(vbuf))) < 0) {
-				perror("video read");
-				playstate = CMoviePlayerGui::STOPPED;
-				break;
-			}
-			vdone = 0;
-			printf("[movieplayer.cpp] vdone=0\n");
-		}
+    //-- write buffer 1 --
+    //--------------------
+    pthread_mutex_lock(&ctx->mtx1);
+    {
+      if (ctx->s[1] != PF_READY)
+      { 
+        ctx->isWriting = false;
+        cntW++;
+        pthread_cond_wait(&(ctx->cond), &(ctx->mtx1));
+        ctx->isWriting = true;
+      }
+
+      if (ctx->s[1] == PF_READY)
+      {
+        wr = write(ctx->dvr, ctx->buf[1], ctx->r[1]);
+        ctx->s[1] = PF_EMPTY;
+        cntB++;
+      }
+      pthread_cond_signal(&(ctx->cond));
+    }  
+    pthread_mutex_unlock(&(ctx->mtx1));
+  
+    if (!ctx->isReading) break; 
+    else if (ctx->wrReset) goto LB_WR_RESET;
+    
+    //-- write buffer 2 --
+    //--------------------
+    pthread_mutex_lock(&ctx->mtx2);
+    {
+      if (ctx->s[2] != PF_READY)
+      { 
+        ctx->isWriting = false;
+        cntW++;
+        pthread_cond_wait(&(ctx->cond), &(ctx->mtx2));
+        ctx->isWriting = true;
+      }
+      
+      if (ctx->s[2] == PF_READY)
+      {
+        wr = write(ctx->dvr, ctx->buf[2], ctx->r[2]);
+        ctx->s[2] = PF_EMPTY;
+        cntB++;
+      }
+      pthread_cond_signal(&(ctx->cond));
+    }  
+    pthread_mutex_unlock(&(ctx->mtx2));
+  
+    if (!ctx->isReading) break; 
+    else if (ctx->wrReset) goto LB_WR_RESET;
+    
+    //-- write buffer 3 --
+    //--------------------
+    pthread_mutex_lock(&ctx->mtx3);
+    {
+      if (ctx->s[3] != PF_READY)
+      { 
+        ctx->isWriting = false;
+        cntW++;
+        pthread_cond_wait(&(ctx->cond), &(ctx->mtx3));
+        ctx->isWriting = true;
+      }
+
+      if (ctx->s[3] == PF_READY)
+      {
+        wr = write(ctx->dvr, ctx->buf[3], ctx->r[3]);
+        ctx->s[3] = PF_EMPTY;
+        cntB++;
+      }
+      pthread_cond_signal(&(ctx->cond));
+    }  
+    pthread_mutex_unlock(&(ctx->mtx3));
+  
+    if (!ctx->isReading) break; 
 
-		if ((ar == 0) && (vr == 0)) {
-            playstate = CMoviePlayerGui::STOPPED;
-            break;
-        }
-        printf("[movieplayer.cpp] vr=%d, ar=%d\n",vr,ar);
-        
-		if (poll(pfd, 2, 0)) {
-			if (pfd[0].revents & POLLOUT) {
-				if ((awr = write(adec, &abuf[adone], ar)) < 0) {
-					if (errno != EAGAIN)
-						perror("audio write");
-				}
-				else {
-					ar -= awr;
-					adone += awr;
-				}
-			}
-			if (pfd[1].revents & POLLOUT) {
-				if ((vwr = write(vdec, &vbuf[vdone], vr)) < 0) {
-					perror("video write");
-				}
-				else {
-					vr -= vwr;
-					vdone += vwr;
-				}
-			}
-		}
-		checkAspectRatio(vdec, false);
-	}
+  }
 
-	ioctl(vdec, VIDEO_STOP);
-	ioctl(adec, AUDIO_STOP);
-	close(vfile);
-	close(afile);
-	close(vdec);
-	close(adec);
-	
-	printf("[movieplayer.cpp] Stopped PES Playback\n");
-		
-	if (playstate != CMoviePlayerGui::STOPPED)
-	{
-		playstate = CMoviePlayerGui::STOPPED;
-		g_RCInput->postMsg (CRCInput::RC_red, 0);	// for faster exit in PlayStream(); do NOT remove!
-	}
+  if (!ctx->isReading)
+    fprintf(stderr,"[mp] writer: reader exit detected\n");
+  
+  ctx->isWriting = false;
+  fprintf(stderr,"[mp] writer terminated, (%ld) buffers processed, (%ld) waits\n", cntB, cntW);
 
-	pthread_exit (NULL);
-	
+  pthread_exit(NULL);
+}  
+
+//== PlayTSFileReadBuffers ==
+//===========================
 
+#if 0
+static bool pauseReader(MP_CTX *ctx, pthread_mutex_t *pmtx)
+{
+  struct timeval  now;
+  struct timespec timeout;
+  
+  gettimeofday(&now, NULL);
+  
+  timeout.tv_sec  = now.tv_sec + 1;
+  timeout.tv_nsec = now.tv_usec * 1000;
+
+  while ( ETIMEDOUT == pthread_cond_timedwait(&(ctx->cond), pmtx, &timeout) )
+  {
+    if (g_playstate == CMoviePlayerGui::STOPPED) return false;  
+  }
+  
+  return true;
 }
+#endif 
 
-	
-//------------------------------------------------------------------------
-void *
-PlayFileThread (void *filename)
+static bool PlayTSFileReadBuffers(MP_CTX *ctx)
 {
-	struct dmx_pes_filter_params p;
-	bool failed = false;
-	unsigned char buf[384 * 188 * 2];
-	unsigned short pida = 0, pidv = 0, ac3=0;
-	int done, fd=-1, dmxa=-1, dmxv = -1, dvr = -1, adec = -1, vdec = -1;
-	ssize_t wr = 0;
-	ssize_t cache = sizeof (buf);
-	size_t r = 0;
-	
-	if ((char *) filename == NULL)
-	{
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
 
-	if ((fd = open ((const char *) filename, O_RDONLY | O_LARGEFILE)) < 0)
-	{
-		playstate = CMoviePlayerGui::STOPPED;
-		pthread_exit (NULL);
-	}
+LB_RD_RESET:
+  ctx->rdReset = false;
 
-	// todo: check if file is valid ts or pes
-	if (isTS)
-	{
-		currentapid = 0;
-		numpida=0;
-		find_all_avpids (fd, &pidv, apids, ac3flags, &numpida);
-		lseek(fd, 0, SEEK_SET);
-		int i;
-	    for (i=0; i<numpida;i++) {
-    	    printf ("[movieplayer.cpp] found pida[%d]: 0x%04X, ac3=%d\n", i,apids[i],ac3flags[i]);
-	    }
-	    if (numpida > 1) {
-    	    showaudioselectdialog = true;
-    	    while (showaudioselectdialog) {
-        	    if (playstate < CMoviePlayerGui::PLAY) {
-            	    // can actually never happen
-            	    close(fd);
-            	    pthread_exit (NULL);
-        	    }
-        	    usleep(100);
-    	    }
-	    }
-
-	    if (currentapid != 0) {
-    	    pida = currentapid;
-	        ac3 = currentac3;
-	        apidchanged = 0;
-        }
-        else {
-            pida = apids[0];
-            ac3 = ac3flags[0];
-            apidchanged = 0;
-            currentapid = pida;
+  //-- read into buffer 0 --
+  //------------------------
+  pthread_mutex_lock(&(ctx->mtx0));
+  {
+    if (ctx->s[0] != PF_EMPTY) pthread_cond_wait(&(ctx->cond),&(ctx->mtx0));
+    //if ( (ctx->s[0] != PF_EMPTY) && !pauseReader(ctx, &(ctx->mtx0)) ) 
+    //  return false;
+  
+    if (ctx->inFp)
+      ctx->r[0] = fread(ctx->buf[0], 1, ctx->readSize, ctx->inFp);
+    else
+      ctx->r[0] = read(ctx->inFd, ctx->buf[0], ctx->readSize);
+    ctx->pos += ctx->r[0];
+    ctx->s[0] = PF_READY;
+  }
+  pthread_mutex_unlock(&(ctx->mtx0));
+
+  if (ctx->r[0] != ctx->readSize)
+  {
+    ctx->isReading = false; 
+    return false;
+  }
+  else
+  {
+    PlayTSFileCheckEvent(ctx);
+    if (ctx->rdReset) goto LB_RD_RESET;
+  }
+  
+  //-- read into buffer 1 --
+  //------------------------
+  pthread_mutex_lock(&(ctx->mtx1));
+  {
+    if (ctx->s[1] != PF_EMPTY) pthread_cond_wait(&(ctx->cond),&(ctx->mtx1));
+    //if ( (ctx->s[1] != PF_EMPTY) && !pauseReader(ctx, &(ctx->mtx1)) ) 
+    //  return false;
+  
+    if (ctx->inFp)
+      ctx->r[1] = fread(ctx->buf[1], 1, ctx->readSize, ctx->inFp);
+    else
+      ctx->r[1] = read(ctx->inFd, ctx->buf[1], ctx->readSize);
+    
+    ctx->pos += ctx->r[1];
+    ctx->s[1] = PF_READY;
+    pthread_cond_signal(&(ctx->cond));
+  }
+  pthread_mutex_unlock(&(ctx->mtx1));
+
+  if (ctx->r[1] != ctx->readSize)
+  { 
+    ctx->isReading = false; 
+    return false;
+  }
+  else
+  {
+    PlayTSFileCheckEvent(ctx);
+    if (ctx->rdReset) goto LB_RD_RESET;
+  }
+  
+  //-- read into buffer 2 --
+  //------------------------
+  pthread_mutex_lock(&(ctx->mtx2));
+  {
+    if (ctx->s[2] != PF_EMPTY) pthread_cond_wait(&(ctx->cond),&(ctx->mtx2));
+    //if ( (ctx->s[2] != PF_EMPTY) && !pauseReader(ctx, &(ctx->mtx2)) ) 
+    //  return false;
+  
+    if (ctx->inFp)
+      ctx->r[2] = fread(ctx->buf[2], 1, ctx->readSize, ctx->inFp);
+    else
+      ctx->r[2] = read(ctx->inFd, ctx->buf[2], ctx->readSize);
+    ctx->pos += ctx->r[2];
+    ctx->s[2] = PF_READY;
+  }
+  pthread_mutex_unlock(&(ctx->mtx2));
+
+  if (ctx->r[2] != ctx->readSize)
+  {
+    ctx->isReading = false; 
+    return false;
+  }
+  else
+  {
+    PlayTSFileCheckEvent(ctx);
+    if (ctx->rdReset) goto LB_RD_RESET;
+  }
+  
+  //-- read into buffer 3 --
+  //------------------------
+  pthread_mutex_lock(&(ctx->mtx3));
+  {
+    if (ctx->s[3] != PF_EMPTY) pthread_cond_wait(&(ctx->cond), &(ctx->mtx3));
+    //if ( (ctx->s[3] != PF_EMPTY) && !pauseReader(ctx, &(ctx->mtx3)) ) 
+    //  return false;
+  
+    if (ctx->inFp)
+      ctx->r[3] = fread(ctx->buf[3], 1, ctx->readSize, ctx->inFp);
+    else
+      ctx->r[3] = read(ctx->inFd, ctx->buf[3], ctx->readSize);
+    
+    ctx->pos += ctx->r[3];
+    ctx->s[3] = PF_READY;
+    
+    pthread_cond_signal(&(ctx->cond));
+  }
+  pthread_mutex_unlock(&(ctx->mtx3));
+
+  if (ctx->r[3] != ctx->readSize)
+  { 
+    ctx->isReading = false; 
+    return false;
+  }
+  else
+    PlayTSFileCheckEvent(ctx);
+
+  return true;
+}
+
+//== PlayTSFileProbe ==
+//=====================
+#define MP_STREAM_MAGIC  "#DBOXSTREAM"
+#define MP_PLAYLST_MAGIC "#DBOXPLAYLST"
+
+static bool PlayTSFileProbe(const char *fname, MP_CTX *ctx)
+{
+  ctx->isStream  = false; 
+  ctx->itChanged = false;
+  ctx->inFp      = NULL;
+  ctx->lst_cnt   = 0;
+  ctx->it        = 0;
+
+  if ( (ctx->inFp = fopen(fname, "r")) == NULL ) 
+    return false; // error 
+  
+  if (fgets(ctx->buf[0], PF_BUF_SIZE-1, ctx->inFp))
+  {
+    //-- check first line for magic value --
+    if (!memcmp(ctx->buf[0], MP_STREAM_MAGIC, sizeof(MP_STREAM_MAGIC)-1))
+    {
+      char *s1, *s2;
+      int  ntokens;
+      
+      //-- get all lines (quick and dirty parser) --
+      while (fgets(ctx->buf[0], PF_BUF_SIZE-1, ctx->inFp))
+      {
+        if ( (s2 = strchr(ctx->buf[0],'#')) != NULL ) *s2 = '\0';
+        if ( strlen(ctx->buf[0]) < 3 ) continue;
+
+        //-------------------------------------------------------------
+        //-- line format:                                            --
+        //-- "<progran name>=<ip>;<port>;<vpid>;<apid>;<zapto-id>\n" --
+        //-- example:                                                --
+        //--   PREMIERE1=dbox;31339;0x1ff;0x2ff;0x20085000a          --
+        //-- Note:                                                   -- 
+        //--   <zapto-id> can be "0" or "-1" to prevent zapping.     --
+        //--    with "-1" pause function will be enabled also.       --
+        //-------------------------------------------------------------
+        ntokens = 0;        
+
+        //-- program name --
+        s1 = ctx->buf[0];
+        if ((s2 = strchr(s1, '=')) != NULL )
+        {
+          ntokens++;
+          *s2 = '\0';
+          ctx->lst[ctx->lst_cnt].pname = s1;
+          s1 = s2+1;
+        }   
+        
+        //-- ip --
+        if ((s2 = strchr(s1, ';')) != NULL )
+        {
+          ntokens++;
+          *s2 = '\0';
+          ctx->lst[ctx->lst_cnt].ip = s1;
+          s1 = s2+1;
         }
         
-	    printf ("[movieplayer.cpp] using pida: 0x%04X ; pidv: 0x%04X ; ac3: %d\n",
-		    pida, pidv, ac3);
-	}
-	else
-	{				// Play PES
-		pida = 0x900;
-		pidv = 0x8ff;
-	}
+        //-- port (in dezimal) --
+        if ((s2 = strchr(s1, ';')) != NULL )
+        {
+          ntokens++;
+          *s2 = '\0';
+          ctx->lst[ctx->lst_cnt].port = strtol(s1, NULL, 10);
+          s1 = s2+1;
+        }   
+
+        //-- vpid (in hex) --
+        if ((s2 = strchr(s1, ';')) != NULL )
+        {
+          ntokens++;
+          *s2 = '\0';
+          ctx->lst[ctx->lst_cnt].vpid = strtol(s1, NULL, 16);
+          s1 = s2+1;
+        }   
+        
+        //-- apid (in hex) --
+        if ((s2 = strchr(s1, ';')) != NULL )
+        {
+          ntokens++;
+          *s2 = '\0';
+          ctx->lst[ctx->lst_cnt].apid = strtol(s1, NULL, 16);
+          s1 = s2+1;
+        }   
+        
+        //-- sid (in hex) --
+        if ((s2 = strchr(s1,'\n')) != NULL ) *s2 = '\0'; 
+        
+        ntokens++;
+        ctx->lst[ctx->lst_cnt].zapid = strtoll(s1, NULL, 16);
+          
+        if (ntokens == 6)
+          ctx->lst_cnt++;
+        else
+          fprintf(stderr, "[mp] parse error in livestream description\n");
+      
+        if (ctx->lst_cnt==PF_LST_ITEMS) break; // prevent overflow
+      }
+      
+      if (ctx->lst_cnt) ctx->isStream=true;
+    }
+    //-- ... or playlist --
+    else if (!memcmp(ctx->buf[0], MP_PLAYLST_MAGIC, sizeof(MP_PLAYLST_MAGIC)-1))
+    {
+      char *s2;
+      
+      while (fgets(ctx->buf[0], PF_BUF_SIZE-1, ctx->inFp))
+      {
+        if ( (s2 = strchr(ctx->buf[0],'#')) != NULL ) *s2 = '\0';
+        if ( strlen(ctx->buf[0]) < 3 ) continue;
+
+        if ( (s2 = strrchr(ctx->buf[0],'\n')) != NULL ) *s2 = '\0';
+        ctx->lst[ctx->lst_cnt].pname = ctx->buf[0];
+        ctx->lst_cnt++;
+        
+        if (ctx->lst_cnt==PF_LST_ITEMS) break; // prevent overflow
+      } 
+    }
+  }
+
+  fclose(ctx->inFp);
+  ctx->inFp = NULL;
+
+  if (ctx->lst_cnt)
+  {
+    fprintf(stderr, "[mp] %s with (%d) entries detected\n",
+            (ctx->isStream)?"(live)stream desc":"playlist", ctx->lst_cnt);
+  }
+    
+  return true;  
 
-	lseek (fd, 0L, SEEK_SET);
-	if ((dmxa = open (DMX, O_RDWR)) < 0
-	    || (dmxv = open (DMX, O_RDWR)) < 0
-	    || (dvr = open (DVR, O_WRONLY)) < 0
-	    || (adec = open (ADEC, O_RDWR)) < 0 || (vdec = open (VDEC, O_RDWR)) < 0)
-	{
-		failed = true;
-	}
+}
 
-	p.input = DMX_IN_DVR;
-	p.output = DMX_OUT_DECODER;
-	p.flags = DMX_IMMEDIATE_START;
-	p.pid = pida;
-	p.pes_type = DMX_PES_AUDIO;
-	if (ioctl (dmxa, DMX_SET_PES_FILTER, &p) < 0)
-		failed = true;
-	p.pid = pidv;
-	p.pes_type = DMX_PES_VIDEO;
-	if (ioctl (dmxv, DMX_SET_PES_FILTER, &p) < 0)
-		failed = true;
-	
-	checkAspectRatio(vdec, true);
-	
-	fileposition = startposition;
-	lseek (fd, fileposition, SEEK_SET);
-	if (isTS && !failed)
-	{
-		int mincache_counter = 0;
-		bool skipwriting = false;
-		while ((r = read (fd, buf, cache)) > 0 && playstate >= CMoviePlayerGui::PLAY)
-		{
-			done = 0;
-			wr = 0;
-			fileposition += r;
-			switch (playstate)
-			{
-			case CMoviePlayerGui::PAUSE:
-				while (playstate == CMoviePlayerGui::PAUSE)
-				{
-					ioctl (dmxa, DMX_STOP);
-				}
-				break;
-			case CMoviePlayerGui::FF:
-			case CMoviePlayerGui::REW:
-				ioctl (dmxa, DMX_STOP);
-                if (mincache_counter == 0) {
-                    lseek (fd, cache * speed, SEEK_CUR);
-                    fileposition += cache * speed;
-                }
-                mincache_counter ++;
-                if (mincache_counter == 2) {
-                    mincache_counter = 0;
-                }
-				break;
-			case CMoviePlayerGui::JF:
-			case CMoviePlayerGui::JB:
-				ioctl (dmxa, DMX_STOP);
-                lseek (fd, jumpminutes * MINUTEOFFSET, SEEK_CUR);
-                fileposition += jumpminutes * MINUTEOFFSET;
-                playstate = CMoviePlayerGui::SOFTRESET;
-                skipwriting = true;
-                break;
-			case CMoviePlayerGui::SOFTRESET:
-				ioctl (vdec, VIDEO_STOP);
-				ioctl (adec, AUDIO_STOP);
-				ioctl (dmxv, DMX_STOP);
-				ioctl (dmxa, DMX_STOP);
-				ioctl (vdec, VIDEO_PLAY);
-				if (ac3 == 1) {
-					ioctl (adec, AUDIO_SET_BYPASS_MODE,0UL);
-				}
-				else
-				{
-					ioctl (adec, AUDIO_SET_BYPASS_MODE,1UL);
-				}
-				ioctl (adec, AUDIO_PLAY);
-				p.pid = pida;
-				p.pes_type = DMX_PES_AUDIO;
-				ioctl (dmxa, DMX_SET_PES_FILTER, &p);
-				p.pid = pidv;
-				p.pes_type = DMX_PES_VIDEO;
-				ioctl (dmxv, DMX_SET_PES_FILTER, &p);
-				ioctl (dmxv, DMX_START);
-				ioctl (dmxa, DMX_START);
-				speed = 1;
-				playstate = CMoviePlayerGui::PLAY;
-				break;
-            case CMoviePlayerGui::AUDIOSELECT:
-        		numpida=0;
-        		find_all_avpids (fd, &pidv, apids, ac3flags, &numpida);
-        		lseek(fd, fileposition, SEEK_SET);
-        		int i;
-        	    for (i=0; i<numpida;i++) {
-            	    printf ("[movieplayer.cpp] found pida[%d]: 0x%04X, ac3=%d\n", i,apids[i],ac3flags[i]);
-        	    }
-        	    showaudioselectdialog = true;
-        	    while (showaudioselectdialog) {
-            	    if (playstate < CMoviePlayerGui::PLAY) {
-                	    // can actually never happen
-                	    //close(fd);
-                	    //pthread_exit (NULL);
-                	    break;
-            	    }
-            	    usleep(100);
-        	    }
-        
-        	    if (currentapid != 0) {
-            	    pida = currentapid;
-        	        ac3 = currentac3;
-        	        apidchanged = 0;
-                }
-                else {
-                    pida = apids[0];
-                    ac3 = ac3flags[0];
-                    apidchanged = 0;
-                    currentapid = pida;
-                }
-                
-        	    printf ("[movieplayer.cpp] using pida: 0x%04X ; pidv: 0x%04X ; ac3: %d\n",
-        		    pida, pidv, ac3);
-                    
-                playstate = CMoviePlayerGui::SOFTRESET;
-                break;
-			case CMoviePlayerGui::STOPPED:
-			case CMoviePlayerGui::PREPARING:
-			case CMoviePlayerGui::STREAMERROR:
-			case CMoviePlayerGui::PLAY:
-			case CMoviePlayerGui::RESYNC:
-			case CMoviePlayerGui::SKIP:
-				break;
-			}
+//== PlayTSFileAnalyze ==
+//=======================
+static void PlayTSFileAnalyze(MP_CTX *ctx)
+{
+#ifndef _MP_SIMULATOR
+  currentapid = 0;  // global
+  numpida     = 0;  // global
 
-			if (!skipwriting) {
-    			do
-    			{
-    				wr = write (dvr, &buf[done], r);
-    				if (!done)
-    					cache = wr;
-    				done += wr;
-    				r -= wr;
-    			}
-    			while (r);
-			}
-			else skipwriting = false;
-			
-			checkAspectRatio(vdec, false);
-		}
-	}
-	else if (!failed)
-	{
-		ioctl (vdec, VIDEO_PLAY);
-		if (ac3 == 1) {
-			ioctl (adec, AUDIO_SET_BYPASS_MODE,0UL);
-		}
-		else
-		{
-			ioctl (adec, AUDIO_SET_BYPASS_MODE,1UL);
-		}
-		ioctl (adec, AUDIO_PLAY);
-		ioctl (dmxv, DMX_START);
-		ioctl (dmxa, DMX_START);
-		pes_to_ts2 (fd, dvr, pida, pidv, (const int *)&playstate);	// VERY bad performance!!!
-	}
+  find_all_avpids (ctx->inFd, &(ctx->pidv), apids, ac3flags, &numpida);
+  lseek(ctx->inFd, ctx->pos, SEEK_SET);
+  
+  for (int i=0; i<numpida; i++) 
+  {
+    fprintf(stderr, "[mp] found pida[%d]: 0x%04X, ac3=%d\n", 
+    i, apids[i], ac3flags[i]);
+  }
+  	    
+  if (numpida > 1) 
+  {
+    showaudioselectdialog = true;
+    while (showaudioselectdialog) usleep(50000);
+  }
+
+  if (!currentapid) 
+  {
+    ctx->pida   = apids[0];
+    ctx->ac3    = ac3flags[0];
+    
+    currentapid = ctx->pida;
+    currentac3  = ctx->ac3;
+  }
+  else
+  {
+    ctx->pida   = currentapid;
+    ctx->ac3    = currentac3;
+  }
+  
+  apidchanged = 0;
+  
+#else
+  find_avpids (ctx->inFd, &(ctx->pidv), &(ctx->pida));
+  lseek(ctx->inFd, 0L, SEEK_SET);
+  
+  ctx->ac3 = is_audio_ac3(ctx->inFd);
+#endif      
+}
 
-	ioctl (vdec, VIDEO_STOP);
-	ioctl (adec, AUDIO_STOP);
-	ioctl (dmxv, DMX_STOP);
-	ioctl (dmxa, DMX_STOP);
-	close (fd);
-	close (dmxa);
-	close (dmxv);
-	close (dvr);
-	close (adec);
-	close (vdec);
-	if (playstate != CMoviePlayerGui::STOPPED)
-	{
-		playstate = CMoviePlayerGui::STOPPED;
-		g_RCInput->postMsg (CRCInput::RC_red, 0);	// for faster exit in PlayStream(); do NOT remove!
-	}
+//== PlayTSFileThread ==
+//======================
+void *PlayTSFileThread (void *filename)
+{
+  std::string fname  = (const char *)filename;
+  std::string actCmd = "";
+  bool        failed = true;
+
+  MP_CTX mpCtx = 
+  {   
+    PTHREAD_MUTEX_INITIALIZER,
+    PTHREAD_MUTEX_INITIALIZER,
+    PTHREAD_MUTEX_INITIALIZER,
+    PTHREAD_MUTEX_INITIALIZER,
+    PTHREAD_COND_INITIALIZER
+  };
+  
+  MP_CTX *ctx = &mpCtx;
+    
+  //-- initial setups --
+  //--------------------
+  ctx->pos = 0L;
+  fprintf(stderr, "[mp] PlayFileThread starts\n");
+
+  //-- open DVB devices --
+  //----------------------
+  if (openDVBDevices(ctx))
+  {
+    //-- check for valid filename --
+    //------------------------------
+    if (fname.length())
+    {
+      //-- check for file type --
+      //-------------------------
+      if ( PlayTSFileProbe(fname.c_str(), ctx) )
+        failed = false;
+      else
+        fprintf(stderr,"[mp] couldn't open (%s) for probing\n", fname.c_str());
+    }
+    else
+      fprintf(stderr,"[mp] invalid filename (null)\n");
+  }
+  else  
+    fprintf(stderr,"[mp] error opening some DVB devices\n");
 
-	pthread_exit (NULL);
+  
+  //-- terminate on error --
+  //------------------------
+  if (failed)
+  {
+    fprintf(stderr, "[mp] PlayTSFileThread terminated\n");
+    g_playstate = CMoviePlayerGui::STOPPED;
+    closeDVBDevices(ctx);
+    pthread_exit(NULL);
+  }
+  
+  do
+  {
+    //-- (live) stream or ... --
+    //--------------------------  
+    if (ctx->isStream)
+    {
+      MP_LST_ITEM *lstIt = &(ctx->lst[ctx->it]);
+
+      ctx->canPause = false;
+      
+      //-- file stream (timeshift) --
+      if (lstIt->zapid < 0)
+        ctx->canPause = true;
+      //-- tv live stream --
+      else if (lstIt->zapid > 0)
+      {
+        sprintf
+        (
+          ctx->buf[0],
+          "wget -q -O - http://%s/control/zapto?0x%llx",
+          lstIt->ip.c_str(), lstIt->zapid
+        );
+        fprintf(stderr, "[mp] zap: %s\n", ctx->buf[0]);
+        system(ctx->buf[0]);
+      }
+      usleep(250000);
+      
+      //-- build wget command and store it for later use -- 
+      sprintf
+      (
+        ctx->buf[0], 
+        "wget -q -O - http://%s:%d/0x%03x,0x%03x", 
+        lstIt->ip.c_str(), lstIt->port, lstIt->vpid, lstIt->apid
+      );
+      actCmd = ctx->buf[0];  
+
+      //-- start reader pipe --
+      if ( (ctx->inFp = popen(ctx->buf[0], "r")) == NULL )
+      {
+        fprintf(stderr, "error: %s\n", ctx->buf[0]);
+        break; // error
+      }
+
+      ctx->pidv     = lstIt->vpid;
+      ctx->pida     = lstIt->apid;
+      ctx->ac3      = 0;
+      
+      ctx->readSize = PF_BUF_SIZE;
+      ctx->fileSize = (off_t)-1;    // is live :-)
+
+    }
+    //-- ... plain TS file (playlist) --
+    //----------------------------------
+    else
+    {
+      if (ctx->lst_cnt) fname = ctx->lst[ctx->it].pname.c_str();
+    
+      if ( (ctx->inFd = open(fname.c_str(), O_RDONLY | O_LARGEFILE)) < 0 )
+      {
+        fprintf(stderr,"[mp] couldn't open (%s)\n", fname.c_str());
+        break; // error
+      }
+
+      ctx->canPause = true;
+      
+      //-- set (short) readsize --
+      ctx->readSize = PF_BUF_SIZE/2;
+
+      //-- analyze TS file (set apid/vpid/ac3 in ctx) --
+      PlayTSFileAnalyze(ctx);
+  
+      //-- get file size --
+      ctx->fileSize = lseek (ctx->inFd, 0L, SEEK_END);
+
+      //-- set bookmark position --
+      ctx->pos = g_startposition;
+      lseek (ctx->inFd, ctx->pos, SEEK_SET);
+      
+      g_startposition = 0;
+    }
+  
+    fprintf
+    (
+      stderr, 
+      "[mp] %s with vpid=(0x%04X) apid=(0x%04X) ac3=(%d)\n",
+      (ctx->isStream)?"(live) stream":"plain TS file",
+      ctx->pidv, ctx->pida, ctx->ac3
+    );
+
+    //-- start writer thread (will wait until buffers'r ready) --
+    //-----------------------------------------------------------
+    if ( PlayTSFileWriterCreate(ctx) )
+    {
+      unsigned long cntL = 0;
+
+      //-- DVB devices softreset --
+      //---------------------------
+      PlayTSFileSoftReset(ctx);
+
+      //-- aspect ratio init --
+      checkAspectRatio(ctx->vdec, true);
+
+      //-- reader loop --
+      //-----------------
+      fprintf(stderr,"[mp] entering reader loop\n");
+      while ( PlayTSFileReadBuffers(ctx) &&
+              (ctx->itChanged == false) &&
+              (g_playstate >= CMoviePlayerGui::PLAY) )
+      {
+        cntL++;
+        g_fileposition = ctx->pos;
+      } 
+     
+      //-- kill live stream process (wget) --
+      //-------------------------------------
+      if (ctx->inFp)
+      {
+        actCmd = "killall -TERM " + actCmd.substr(0,actCmd.find(' '));
+        system(actCmd.c_str());
+      }
+      
+      fprintf(stderr,"[mp] leaving reader loop after (%ld) turns\n", cntL);
+
+      //-- force end of writer thread --
+      //--------------------------------
+      ctx->isReading = false;
+      pthread_cond_signal(&(ctx->cond)); // wake up ...
+      pthread_join(ctx->wThread, NULL);  // ... and wait.
+
+      fprintf(stderr,"[mp] reader terminated (last pos=%ldM)\n", 
+              (unsigned long)(ctx->pos/(1024*1024)));
+    } 
+
+    //-- close input --
+    //-----------------
+    if (ctx->inFp) 
+    { 
+      fclose(ctx->inFp);
+      ctx->inFp = NULL;
+    }
+    else if (ctx->inFd != -1)
+    {
+      //-- eventually activate autoplay for next file in a playlist --
+      if ( (ctx->itChanged == false) && ctx->lst_cnt ) 
+      {
+        ctx->it++;
+        if (ctx->it < ctx->lst_cnt) ctx->itChanged = true;
+      }
+      
+      close(ctx->inFd);
+      ctx->inFd = -1;
+    }
+    
+    //-- Note: on any content change AV should be freezed first,   --
+    //-- to get a consitant state. restart of all DVB-devices will --
+    //-- be initiated by a SoftReset in following turns/starts.    --
+    PlayTSFileFreezeAV(ctx, true);
+
+    //-- check for another item to play --
+    //------------------------------------
+    if (g_playstate >= CMoviePlayerGui::PLAY && ctx->itChanged)
+    {
+      ctx->itChanged = false;
+      g_playstate    = CMoviePlayerGui::PLAY;
+
+      //updateLcd(ctx->lst[ctx->it].pname);
+    }
+    else
+      break; // normal loop exit
+
+  } while (1);
+ 
+  //-- stop and close DVB devices --
+  //--------------------------------
+  closeDVBDevices(ctx);
+
+  if (g_playstate != CMoviePlayerGui::STOPPED)
+  {
+    g_playstate = CMoviePlayerGui::STOPPED;
+    g_RCInput->postMsg (CRCInput::RC_red, 0);	// for faster exit in PlayStream(); do NOT remove!
+  }
+
+  fprintf(stderr, "[mp] PlayTSFileThread terminated\n");
+  pthread_exit (NULL);
 }
 
+//=======================================
+//== CMoviePlayerGui::ParentalEntrance ==
+//=======================================
+#define CI_MAX 4
 
-void updateLcd(const std::string & sel_filename)
+void CMoviePlayerGui::ParentalEntrance(void)
 {
-	char tmp[20];
-	std::string lcd;
-	
-	switch(playstate)
-	{
-	case CMoviePlayerGui::PAUSE:
-		lcd = "|| (";
-		lcd += sel_filename;
-		lcd += ')';
-		break;
-	case CMoviePlayerGui::REW:
-		sprintf(tmp, "%dx<< ", speed);
-		lcd = tmp;
-		lcd += sel_filename;
-		break;
-	case CMoviePlayerGui::FF:
-		sprintf(tmp, "%dx>> ", speed);
-		lcd = tmp;
-		lcd += sel_filename;
-		break;
-	default:
-		lcd = "> ";
-		lcd += sel_filename;
-		break;
-	}
-	
-	CLCD::getInstance()->showServicename(lcd);
+  neutrino_msg_t      msg;
+  neutrino_msg_data_t data;
+
+  char code1[CI_MAX+1];
+  char code2[CI_MAX+1];
+  bool done = false;
+  int  ci   = 0;
+  
+  g_playstate = CMoviePlayerGui::STOPPED;
+  do
+  {
+    //-- check RC code --
+    //-------------------
+    g_RCInput->getMsg (&msg, &data, 10);  // 1 secs..
+    switch(msg)
+    {
+      case CRCInput::RC_0:
+      case CRCInput::RC_1:
+      case CRCInput::RC_2:
+      case CRCInput::RC_3:
+      case CRCInput::RC_4:
+      case CRCInput::RC_5:
+      case CRCInput::RC_6:
+      case CRCInput::RC_7:
+      case CRCInput::RC_8:
+      case CRCInput::RC_9:
+        code2[ci++] = msg - CRCInput::RC_1 + '1';
+        
+        if (ci>=CI_MAX)
+        {
+          int  n   = 0;
+          FILE *fp = NULL;
+
+          //-- get reference code from file (or set default "2222") -- 
+          if ( (fp = fopen("/var/tuxbox/config/mpcode","r")) != NULL )
+          {
+            n = fread(code1, 1, CI_MAX, fp);
+            fclose(fp);
+          }
+          if (n != CI_MAX) strcpy(code1,"2222");
+          
+          code1[CI_MAX] = '\0';
+          code2[CI_MAX] = '\0';
+          if (!strcmp(code1, code2))
+          {
+            fprintf(stderr, "[mp] pass ok!\n"); 
+            PlayFile(1);  
+          }
+          else
+          {  
+            //-- TODO: message box (see movieplayer help) --  
+            fprintf(stderr, "[mp] pass failed\n"); 
+          }
+          done = true;
+        }
+        break;
+
+      //-- Exit for Record/Zapto Timers  etc. --
+      case NeutrinoMessages::RECORD_START:
+      case NeutrinoMessages::ZAPTO:
+      case NeutrinoMessages::STANDBY_ON:
+      case NeutrinoMessages::SHUTDOWN:
+      case NeutrinoMessages::SLEEPTIMER:
+        g_RCInput->postMsg (msg, data);
+        done = true;
+        break;
+ 
+      default:
+        if (CNeutrinoApp::getInstance()->handleMsg(msg, data) & messages_return::cancel_all)
+          done = true;
+        break;
+    }
+  }
+  while ( done==false );
 }
 
-//------------------------------------------------------------------------
+#ifndef _MP_SIMULATOR
+//===============================
+//== CMoviePlayerGui::PlayFile ==
+//===============================
+int CMoviePlayerGui::lastParental = -1;
+
+void CMoviePlayerGui::PlayFile (int parental)
+{
+  neutrino_msg_t      msg;
+  neutrino_msg_data_t data;
+
+  std::string sel_filename;
+  std::string hlpstr;
+
+  CTimeOSD    FileTime;
+  bool        update_lcd       = true;
+  bool        open_filebrowser = true;
+  bool        start_play       = false;
+  bool        done             = false;
+  bool        rc_blocked       = false;
+  
+  g_playstate = CMoviePlayerGui::STOPPED;
+  /* g_playstate == CMoviePlayerGui::STOPPED         : stopped
+   * g_playstate == CMoviePlayerGui::PLAY            : playing
+   * g_playstate == CMoviePlayerGui::PAUSE           : pause-mode
+   * g_playstate == CMoviePlayerGui::FF              : fast-forward
+   * g_playstate == CMoviePlayerGui::REW             : rewind
+   * g_playstate == CMoviePlayerGui::SOFTRESET       : softreset without clearing buffer (g_playstate toggle to 1)
+   */
+
+  //-- switch parental access via user definable script --
+  if (parental != lastParental)
+  {
+    fprintf(stderr,"[mp] setting parental to (%d)\n", parental);
+    lastParental = parental;
+
+    hlpstr = "/var/bin/parental.sh";
+    if (parental==1) hlpstr += " 1"; else hlpstr += " 0";
+    system(hlpstr.c_str());
+  }
+	 
+  do
+  {
+    //-- bookmark playback --
+    //-----------------------
+    if (isBookmark) 
+    {
+      open_filebrowser = false;
+      filename         = startfilename.c_str();
+      sel_filename     = startfilename;
+      update_lcd       = true;
+      start_play       = true;
+      isBookmark       = false;
+    }
+
+    //-- file browser --
+    //------------------
+    if (open_filebrowser)
+    {
+      open_filebrowser    = false;
+      filename            = NULL;
+      filebrowser->Filter = &tsfilefilter;
+
+      if (filebrowser->exec(Path_local.c_str()))
+      {
+        Path_local = filebrowser->getCurrentDir();
+        CFile *file;
+    
+        if ((file = filebrowser->getSelectedFile()) != NULL)
+        {
+          filename     = file->Name.c_str();
+          sel_filename = file->getFileName();
+          
+          update_lcd   = true;
+          start_play   = true;
+        }
+      }
+      else
+      {
+        if (g_playstate == CMoviePlayerGui::STOPPED) break;
+      }
+
+      CLCD::getInstance()->setMode (CLCD::MODE_TVRADIO);
+    }
+
+    //-- LCD display --
+    //-----------------
+    if (update_lcd)
+    {
+      update_lcd = false;
+      updateLcd(sel_filename);
+    }
+
+    //-- start threaded playback --
+    //-----------------------------
+    if (start_play)
+    {
+      fprintf(stderr, "[mp] Startplay\n");
+      start_play = false;
+
+      if (g_playstate >= CMoviePlayerGui::PLAY)
+      {
+        g_playstate = CMoviePlayerGui::STOPPED;
+        pthread_join (rct, NULL);
+      }
+
+      g_playstate = CMoviePlayerGui::PLAY;  // !!!
+
+      //-- create player thread --
+      if (pthread_create(&rct, 0, PlayTSFileThread, (void *)filename) != 0)
+      {
+        fprintf(stderr, "[mp] couldn't create player thread\n");
+        break;
+      }
+
+    }
+
+    //-- audio track selector                  --
+    // input:  numpida                         --
+    //         ac3flags[numpida]               --
+    //         currentapid = 0                 --
+    // ouptut: currentapid (may be remain 0,   --
+    //           if nothing happened)          -- 
+    //         currentac3                      --
+    //         apidchanged (0/1, but not used) --
+    //-------------------------------------------
+    if (showaudioselectdialog) 
+    {
+      CMenuWidget APIDSelector(LOCALE_APIDSELECTOR_HEAD, "audio.raw", 300);
+      APIDSelector.addItem(GenericMenuSeparator);
+      apidchanged = 0;
+
+      CAPIDSelectExec *APIDChanger = new CAPIDSelectExec;
+
+      for( unsigned int count=0; count<numpida; count++ )
+      {
+        char apidnumber[3];
+        sprintf(apidnumber, "%d", count+1);
+
+        std::string apidtitle = "Stream ";
+        apidtitle.append(apidnumber);
+  
+        if (ac3flags[count]) apidtitle.append(" (AC3)");
+              
+         APIDSelector.addItem
+         (
+           new CMenuForwarderNonLocalized
+           (
+             apidtitle.c_str(), true, NULL, APIDChanger, apidnumber, 
+             CRCInput::convertDigitToKey(count+1)
+           ), 
+           (count == 0)
+         );
+      }
+
+      APIDSelector.exec(NULL, "");
+      showaudioselectdialog = false;
+    }
+
+    //-- filetime display -- 
+    //----------------------
+    if(FileTime.IsVisible())
+    {
+      FileTime.update();
+    }
+
+    //-- check RC code --
+    //-------------------
+    g_RCInput->getMsg (&msg, &data, 10);  // 1 secs..
+    switch(msg)
+    {
+      //-- exit play --
+      case CRCInput::RC_red:
+      case CRCInput::RC_home:
+        done = true;
+        break;
+
+      //-- pause / play --
+      case CRCInput::RC_yellow:
+        if (rc_blocked == false) // prevent to fast repeats
+        {
+          update_lcd  = true;
+          //g_playstate = (g_playstate == CMoviePlayerGui::PAUSE) ? CMoviePlayerGui::SOFTRESET : CMoviePlayerGui::PAUSE;
+          g_playstate = (g_playstate == CMoviePlayerGui::PAUSE) ? CMoviePlayerGui::PLAY : CMoviePlayerGui::PAUSE;
+          rc_blocked  = true;
+        }
+        break;
+
+      //-- invoke bookmark manager --
+      case CRCInput::RC_blue:
+        if (bookmarkmanager->getBookmarkCount() < bookmarkmanager->getMaxBookmarkCount())
+        {
+          char timerstring[200];
+          fprintf(stderr, "fileposition: %lld\n",g_fileposition);
+          sprintf(timerstring, "%lld",g_fileposition);
+          fprintf(stderr, "timerstring: %s\n",timerstring);
+          std::string bookmarktime = "";
+          bookmarktime.append(timerstring);
+          fprintf(stderr, "bookmarktime: %s\n",bookmarktime.c_str());
+          bookmarkmanager->createBookmark(filename, bookmarktime);
+        }
+        else
+        {
+          fprintf(stderr, "too many bookmarks\n");
+          DisplayErrorMessage(g_Locale->getText(LOCALE_MOVIEPLAYER_TOOMANYBOOKMARKS)); // UTF-8
+        }
+        break;
+
+      //-- request for audio selector --
+      case CRCInput::RC_green:
+        g_playstate = CMoviePlayerGui::AUDIOSELECT;
+        break;
+
+      //-- Help --
+      case CRCInput::RC_help:
+        hlpstr = g_Locale->getText(LOCALE_MOVIEPLAYER_TSHELP);
+        hlpstr += "\nVersion: $Revision: 1.1 $\n\nMovieplayer (c) 2003, 2004 by gagga";
+        ShowMsgUTF(LOCALE_MESSAGEBOX_INFO, hlpstr.c_str(), CMessageBox::mbrBack, CMessageBox::mbBack, "info.raw"); // UTF-8
+        break;
+
+      //-- filetime on/off --
+      case CRCInput::RC_setup:
+        if(FileTime.IsVisible())
+          FileTime.hide();
+        else
+          FileTime.show(g_fileposition / (MINUTEOFFSET/60));
+        break;
+
+      //-- rewind & fast forward --
+      case CRCInput::RC_left:
+      case CRCInput::RC_right:
+        break;
+
+      //-- Softreset --
+      case CRCInput::RC_0:
+        if (g_playstate != CMoviePlayerGui::PAUSE)
+          g_playstate = CMoviePlayerGui::SOFTRESET;
+        break;
+
+      //-- jump 1 minute back --
+      case CRCInput::RC_1:
+        g_jumpminutes = -1;
+        g_playstate   = CMoviePlayerGui::JB;
+        update_lcd    = true;
+        FileTime.hide();
+        break;
+
+      //-- jump 1 minute forward --    
+      case CRCInput::RC_3:
+        g_jumpminutes = 1;
+        g_playstate   = CMoviePlayerGui::JF;
+        update_lcd    = true;
+        FileTime.hide();
+        break;
+
+      //-- jump 5 minutes back --
+      case CRCInput::RC_4:
+        g_jumpminutes = -5;
+        g_playstate = CMoviePlayerGui::JB;
+        update_lcd = true;
+        FileTime.hide();
+        break;
+
+      //-- jump 5 minutes forward --
+      case CRCInput::RC_6:
+        g_jumpminutes = 5;
+        g_playstate   = CMoviePlayerGui::JF;
+        update_lcd    = true;
+        FileTime.hide();
+        break;
+
+      //-- jump 10 minutes back -- 
+      case CRCInput::RC_7:
+        g_jumpminutes = -10;
+        g_playstate   = CMoviePlayerGui::JB;
+        update_lcd    = true;
+        FileTime.hide();
+        break;
+
+      //-- jump 10 minutes back --
+      case CRCInput::RC_9:
+        g_jumpminutes = 10;
+        g_playstate   = CMoviePlayerGui::JF;
+        update_lcd    = true;
+        FileTime.hide();
+        break;
+
+      //-- next/prev item --  
+      case CRCInput::RC_up:
+        g_playstate = CMoviePlayerGui::ITEMSELECT;
+        g_itno      = -2;
+        break;
+
+      case CRCInput::RC_down:
+        g_playstate = CMoviePlayerGui::ITEMSELECT;
+        g_itno      = -1;
+        break;
+
+      case CRCInput::RC_ok:
+        if (g_playstate > CMoviePlayerGui::PLAY)
+        {
+          update_lcd = true;
+          g_playstate = CMoviePlayerGui::SOFTRESET;
+        }
+        else
+          open_filebrowser = true;
+        break;
+
+      case NeutrinoMessages::RECORD_START:
+      case NeutrinoMessages::ZAPTO:
+      case NeutrinoMessages::STANDBY_ON:
+      case NeutrinoMessages::SHUTDOWN:
+      case NeutrinoMessages::SLEEPTIMER:
+        // Exit for Record/Zapto Timers
+        fprintf(stderr,"[mp] teminating due to high-prio event\n");
+        done = true;
+        g_RCInput->postMsg (msg, data);
+        break;
+ 
+      default:
+        if (CNeutrinoApp::getInstance()->handleMsg(msg, data) & messages_return::cancel_all)
+        {
+          fprintf(stderr, "[mp] terminating due to cancel_all request\n");  
+          done = true;
+        }
+
+        rc_blocked = false;   
+        break;
+    }
+  }
+  while ( (g_playstate >= CMoviePlayerGui::PLAY) && (done==false) );
+  
+  g_playstate = CMoviePlayerGui::STOPPED;
+
+  pthread_join (rct, NULL);
+}
+#endif
+
+// ... GMO snip end
+
+
+//=================================
+//== CMoviePlayerGui::PlayStream ==
+//=================================
 #define SKIPPING_DURATION 3
 void
 CMoviePlayerGui::PlayStream (int streamtype)
@@ -1565,7 +2624,7 @@
 
 	}
 
-	playstate = CMoviePlayerGui::STOPPED;
+	g_playstate = CMoviePlayerGui::STOPPED;
 	/* playstate == CMoviePlayerGui::STOPPED         : stopped
 	 * playstate == CMoviePlayerGui::PREPARING       : preparing stream from server
 	 * playstate == CMoviePlayerGui::ERROR           : error setting up server
@@ -1582,9 +2641,9 @@
 		if (exit)
 		{
 			exit = false;
-			if (playstate >= CMoviePlayerGui::PLAY)
+			if (g_playstate >= CMoviePlayerGui::PLAY)
 			{
-				playstate = CMoviePlayerGui::STOPPED;
+				g_playstate = CMoviePlayerGui::STOPPED;
 				break;
 			}
 		}
@@ -1632,7 +2691,7 @@
 			}
 			else
 			{
-				if (playstate == CMoviePlayerGui::STOPPED)
+				if (g_playstate == CMoviePlayerGui::STOPPED)
 					break;
 			}
 
@@ -1651,9 +2710,9 @@
 			bufferfilled = false;
 			avpids_found=false;
 	  
-			if (playstate >= CMoviePlayerGui::PLAY)
+			if (g_playstate >= CMoviePlayerGui::PLAY)
 			{
-				playstate = CMoviePlayerGui::STOPPED;
+				g_playstate = CMoviePlayerGui::STOPPED;
 				pthread_join (rct, NULL);
 			}
 			//TODO: Add Dialog (Remove Dialog later)
@@ -1664,7 +2723,7 @@
 			{
 				break;
 			}
-			playstate = CMoviePlayerGui::SOFTRESET;
+			g_playstate = CMoviePlayerGui::SOFTRESET;
 		}
 
 		g_RCInput->getMsg (&msg, &data, 10);	// 1 secs..
@@ -1680,12 +2739,12 @@
 		else if (msg == CRCInput::RC_yellow)
 		{
 			update_info = true;
-			playstate = (playstate == CMoviePlayerGui::PAUSE) ? CMoviePlayerGui::SOFTRESET : CMoviePlayerGui::PAUSE;
+			g_playstate = (g_playstate == CMoviePlayerGui::PAUSE) ? CMoviePlayerGui::SOFTRESET : CMoviePlayerGui::PAUSE;
 			StreamTime.hide();
 		}
 		else if (msg == CRCInput::RC_green)
 		{
-			if (playstate == CMoviePlayerGui::PLAY) playstate = CMoviePlayerGui::RESYNC;
+			if (g_playstate == CMoviePlayerGui::PLAY) g_playstate = CMoviePlayerGui::RESYNC;
 			StreamTime.hide();
 		}
 		else if (msg == CRCInput::RC_blue)
@@ -1713,37 +2772,37 @@
 		else if (msg == CRCInput::RC_1)
 		{
 			skipvalue = "-00:01:00";
-			playstate = CMoviePlayerGui::SKIP;
+			g_playstate = CMoviePlayerGui::SKIP;
 			StreamTime.hide();
 		}
 		else if (msg == CRCInput::RC_3)
 		{
 			skipvalue = "+00:01:00";
-			playstate = CMoviePlayerGui::SKIP;
+			g_playstate = CMoviePlayerGui::SKIP;
 			StreamTime.hide();
 		}
 		else if (msg == CRCInput::RC_4)
 		{
 			skipvalue = "-00:05:00";
-			playstate = CMoviePlayerGui::SKIP;
+			g_playstate = CMoviePlayerGui::SKIP;
 			StreamTime.hide();
 		}
 		else if (msg == CRCInput::RC_6)
 		{
 			skipvalue = "+00:05:00";
-			playstate = CMoviePlayerGui::SKIP;
+			g_playstate = CMoviePlayerGui::SKIP;
 			StreamTime.hide();
 		}
 		else if (msg == CRCInput::RC_7)
 		{
 			skipvalue = "-00:10:00";
-			playstate = CMoviePlayerGui::SKIP;
+			g_playstate = CMoviePlayerGui::SKIP;
 			StreamTime.hide();
 		}
 		else if (msg == CRCInput::RC_9)
 		{
 			skipvalue = "+00:10:00";
-			playstate = CMoviePlayerGui::SKIP;
+			g_playstate = CMoviePlayerGui::SKIP;
 			StreamTime.hide();
 		}
 		else if (msg == CRCInput::RC_down)
@@ -1758,7 +2817,7 @@
 				skipvalue = tmp;
 				if(skipvalue[0]== '=')
 					skipvalue = skipvalue.substr(1);
-				playstate = CMoviePlayerGui::SKIP;
+				g_playstate = CMoviePlayerGui::SKIP;
 				StreamTime.hide();
 			}
 		}
@@ -1794,7 +2853,7 @@
 		else if (msg == CRCInput::RC_help)
  		{
 			std::string fullhelptext = g_Locale->getText(LOCALE_MOVIEPLAYER_VLCHELP);
-			fullhelptext += "\nVersion: $Revision: 1.1 $\n\nMovieplayer (c) 2003, 2004 by gagga";
+			fullhelptext += "\nVersion: $Revision: 1.1 $\n\nMovieplayer (c) 2003, 2004 by gagga";
 			ShowMsgUTF(LOCALE_MESSAGEBOX_INFO, fullhelptext.c_str(), CMessageBox::mbrBack, CMessageBox::mbBack, "info.raw"); // UTF-8
  		}
 		else
@@ -1814,308 +2873,10 @@
 					exit = true;
 				}
 	}
-	while (playstate >= CMoviePlayerGui::PLAY);
+	while (g_playstate >= CMoviePlayerGui::PLAY);
 	pthread_join (rct, NULL);
 }
 
-void
-CMoviePlayerGui::PlayFile (void)
-{
-	neutrino_msg_t      msg;
-	neutrino_msg_data_t data;
-
-	std::string sel_filename;
-	CTimeOSD FileTime;
-	bool update_lcd = true, open_filebrowser =
-		true, start_play = false, exit = false;
-	playstate = CMoviePlayerGui::STOPPED;
-	/* playstate == CMoviePlayerGui::STOPPED         : stopped
-	 * playstate == CMoviePlayerGui::PLAY            : playing
-	 * playstate == CMoviePlayerGui::PAUSE           : pause-mode
-	 * playstate == CMoviePlayerGui::FF              : fast-forward
-	 * playstate == CMoviePlayerGui::REW             : rewind
-	 * playstate == CMoviePlayerGui::SOFTRESET       : softreset without clearing buffer (playstate toggle to 1)
-	 */
-	 
-	do
-	{
-		if (exit)
-		{
-			exit = false;
-			if (playstate >= CMoviePlayerGui::PLAY)
-			{
-				playstate = CMoviePlayerGui::STOPPED;
-				break;
-			}
-		}
-
-		if (isBookmark) 
-		{
-    	    open_filebrowser=false;
-    	    filename = startfilename.c_str();
-    	    sel_filename = startfilename;
-    	    update_lcd = true;
-			start_play = true;
-			isBookmark = false;
-
-    		
-		}
-		if (open_filebrowser)
-		{
-			open_filebrowser = false;
-			filename = NULL;
-			if (isTS)
-			{
-			    filebrowser->Filter = &tsfilefilter;
-		    }
-			else 
-			{
-    			if (isPES) {
-        			filebrowser->Filter = &pesfilefilter;
-    			}
-			}
-			if (filebrowser->exec(Path_local.c_str()))
-			{
-				Path_local = filebrowser->getCurrentDir();
-				CFile * file;
-				if ((file = filebrowser->getSelectedFile()) != NULL)
-				{
-					filename = file->Name.c_str();
-					update_lcd = true;
-					start_play = true;
-					sel_filename = filebrowser->getSelectedFile()->getFileName();
-				}
-			}
-			else
-			{
-				if (playstate == CMoviePlayerGui::STOPPED)
-					break;
-			}
-
-			CLCD::getInstance ()->setMode (CLCD::MODE_TVRADIO);
-		}
-
-		if (update_lcd)
-		{
-			update_lcd = false;
-			updateLcd(sel_filename);
-		}
-
-		if (start_play)
-		{
-			printf("Startplay\n");
-			start_play = false;
-			if (playstate >= CMoviePlayerGui::PLAY)
-			{
-				playstate = CMoviePlayerGui::STOPPED;
-				pthread_join (rct, NULL);
-			}
-
-			if (isTS) {
-			    if (pthread_create
-			        (&rct, 0, PlayFileThread, (void *) filename) != 0)
-			    {
-				    break;
-			    }
-			}
-			    
-			else {
-			    if (isPES && pthread_create
-			        (&rct, 0, PlayPESFileThread, (void *) filename) != 0)
-			    {
-				    break;
-			    }
-		    }
-			playstate = CMoviePlayerGui::SOFTRESET;
-		}
-
-		if (showaudioselectdialog) {
-			CMenuWidget APIDSelector(LOCALE_APIDSELECTOR_HEAD, "audio.raw", 300);
-			APIDSelector.addItem(GenericMenuSeparator);
-			apidchanged = 0;
-			CAPIDSelectExec *APIDChanger;
-			APIDChanger = new CAPIDSelectExec;
-			for( unsigned int count=0; count<numpida; count++ )
-			{
-				char apidnumber[3];
-				sprintf(apidnumber, "%d", count+1);
-				
-				std::string apidtitle = "Stream ";
-				apidtitle.append(apidnumber);
-				if (ac3flags[count]) {
-					apidtitle.append(" (AC3)");
-				}
-				
-				APIDSelector.addItem(new CMenuForwarderNonLocalized(apidtitle.c_str(), true, NULL, APIDChanger, apidnumber, CRCInput::convertDigitToKey(count+1)), (count == 0));
-			}
-			APIDSelector.exec(NULL, "");
-			if (currentapid == 0) {
-				currentapid = apids[0];
-				currentac3 = ac3flags[0];
-			}
-			showaudioselectdialog = false;
-		}
-        		
-		g_RCInput->getMsg (&msg, &data, 10);	// 1 secs..
-		if(FileTime.IsVisible())
-		{
-			FileTime.update();
-		}
-		if (msg == CRCInput::RC_red || msg == CRCInput::RC_home)
-		{
-			//exit play
-			exit = true;
-		}
-		else if (msg == CRCInput::RC_yellow)
-		{
-			update_lcd = true;
-			playstate = (playstate == CMoviePlayerGui::PAUSE) ? CMoviePlayerGui::SOFTRESET : CMoviePlayerGui::PAUSE;
-		}
-		else if (msg == CRCInput::RC_blue)
-		{
-			if (bookmarkmanager->getBookmarkCount() < bookmarkmanager->getMaxBookmarkCount())
-			{
-				char timerstring[200];
-				printf("fileposition: %lld\n",fileposition);
-				sprintf(timerstring, "%lld",fileposition);
-				printf("timerstring: %s\n",timerstring);
-				std::string bookmarktime = "";
-				bookmarktime.append(timerstring);
-				printf("bookmarktime: %s\n",bookmarktime.c_str());
-				bookmarkmanager->createBookmark(filename, bookmarktime);
-			}
-			else
-			{
-				printf("too many bookmarks\n");
-				DisplayErrorMessage(g_Locale->getText(LOCALE_MOVIEPLAYER_TOOMANYBOOKMARKS)); // UTF-8
-			}
-		}
-		else if (msg == CRCInput::RC_green)
-		{
-    		playstate = CMoviePlayerGui::AUDIOSELECT;
-        }
- 		else if (msg == CRCInput::RC_help)
- 		{
-			std::string fullhelptext = g_Locale->getText(LOCALE_MOVIEPLAYER_TSHELP);
-			fullhelptext += "\nVersion: $Revision: 1.1 $\n\nMovieplayer (c) 2003, 2004 by gagga";
-			ShowMsgUTF(LOCALE_MESSAGEBOX_INFO, fullhelptext.c_str(), CMessageBox::mbrBack, CMessageBox::mbBack, "info.raw"); // UTF-8
- 		}
- 		else if (msg == CRCInput::RC_setup)
- 		{
-			if(FileTime.IsVisible())
-			{
-				FileTime.hide();
-			}
-			else
-			{
-				FileTime.show(fileposition / (MINUTEOFFSET/60));
-			}
- 		}
-		else if (msg == CRCInput::RC_left)
-		{
-			// rewind
-			if (speed > 1)
-				speed = 1;
-			speed *= -2;
-			speed *= (speed > 1 ? -1 : 1);
-			playstate = CMoviePlayerGui::REW;
-			update_lcd = true;
-			FileTime.hide();
-		}
-		else if (msg == CRCInput::RC_right)
-		{
-			// fast-forward
-			if (speed < 1)
-				speed = 1;
-			speed *= 2;
-			playstate = CMoviePlayerGui::FF;
-			update_lcd = true;
-			FileTime.hide();
-		}
-		else if (msg == CRCInput::RC_1)
-		{
-			// Jump Backwards 1 minute
-			jumpminutes = -1;
-			playstate = CMoviePlayerGui::JB;
-			update_lcd = true;
-			FileTime.hide();
-		}
-		else if (msg == CRCInput::RC_3)
-		{
-			// Jump Forward 1 minute
-			jumpminutes = 1;
-			playstate = CMoviePlayerGui::JF;
-			update_lcd = true;
-			FileTime.hide();
-		}
-		else if (msg == CRCInput::RC_4)
-		{
-			// Jump Backwards 5 minutes
-			jumpminutes = -5;
-			playstate = CMoviePlayerGui::JB;
-			update_lcd = true;
-			FileTime.hide();
-		}
-		else if (msg == CRCInput::RC_6)
-		{
-			// Jump Forward 5 minutes
-			jumpminutes = 5;
-			playstate = CMoviePlayerGui::JF;
-			update_lcd = true;
-			FileTime.hide();
-		}
-		else if (msg == CRCInput::RC_7)
-		{
-			// Jump Backwards 10 minutes
-			jumpminutes = -10;
-			playstate = CMoviePlayerGui::JB;
-			update_lcd = true;
-			FileTime.hide();
-		}
-		else if (msg == CRCInput::RC_9)
-		{
-			// Jump Forward 10 minutes
-			jumpminutes = 10;
-			playstate = CMoviePlayerGui::JF;
-			update_lcd = true;
-			FileTime.hide();
-		}
-		else if (msg == CRCInput::RC_up || msg == CRCInput::RC_down)
-		{
-			// todo: next/prev file
-		}
-		else if (msg == CRCInput::RC_ok)
-		{
-			if (playstate > CMoviePlayerGui::PLAY)
-			{
-				update_lcd = true;
-				playstate = CMoviePlayerGui::SOFTRESET;
-			}
-			else
-				open_filebrowser = true;
-		}
-		else
-			if (msg == NeutrinoMessages::RECORD_START
-			    || msg == NeutrinoMessages::ZAPTO
-			    || msg == NeutrinoMessages::STANDBY_ON
-			    || msg == NeutrinoMessages::SHUTDOWN
-			    || msg == NeutrinoMessages::SLEEPTIMER)
-			{
-				// Exit for Record/Zapto Timers
-				isTS = true;		// also exit in PES Mode
-				exit = true;
-				g_RCInput->postMsg (msg, data);
-			}
-			else
-				if (CNeutrinoApp::getInstance()->handleMsg(msg, data) & messages_return::cancel_all)
-				{
-					isTS = true;		// also exit in PES Mode
-					exit = true;
-				}
-	}
-	while (playstate >= CMoviePlayerGui::PLAY);
-	pthread_join (rct, NULL);
-}
 
 // checks if AR has changed an sets cropping mode accordingly (only video mode auto)
 void checkAspectRatio (int vdec, bool init)
